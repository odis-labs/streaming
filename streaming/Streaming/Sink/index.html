<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Sink (streaming.Streaming.Sink)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../index.html">streaming</a> &#x00BB; <a href="../index.html">Streaming</a> &#x00BB; Sink</nav><h1>Module <code>Streaming.Sink</code></h1><p>Module with defintions for sinks.</p><p>Sinks are streaming abstractions that consume values and produce an aggregated value as a result. The result value is extracted from an internal state that is built incrementally. The internal state can aquire resources that are guaranteed to be terminated when the sink is filled.</p><p>Sinks are a great way to define decoupled consumers that can be filled with <a href="../Stream/index.html#val-into"><code>Stream.into</code></a>.</p><p>Sinks are independent from sources and streams. You can think of them as packed arguments for folding functions with early termination. Formally, they can also be interpreted as <a href="https://en.wikipedia.org/wiki/Moore_machine">Moore machine</a>.</p><nav class="toc"><ul><li><a href="#creating-a-sink">Creating a sink</a></li><li><a href="#basic-sinks">Basic sinks</a></li><li><a href="#finding-elements">Finding elements</a></li><li><a href="#logical-predicates">Logical predicates</a></li><li><a href="#data-sinks">Data sinks</a></li><li><a href="#io-sinks">IO sinks</a></li><li><a href="#numeric-computations">Numeric computations</a></li><li><a href="#combining-sinks">Combining sinks</a></li><li><a href="#mapping-and-filtering-sinks">Mapping and filtering sinks</a></li><li><a href="#resource-management">Resource management</a></li><li><a href="#syntax-definitions">Syntax definitions</a></li><li><a href="#interface-implementations">Interface implementations</a></li></ul></nav></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> <span>('a, 'b) t</span></code><code> = <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="../index.html#type-sink">sink</a></span></code></dt><dd><p>Type for sinks that consume elements of type <code>'a</code> and, once done, produce a value of type <code>'b</code>.</p></dd></dl><section><header><h2 id="creating-a-sink"><a href="#creating-a-sink" class="anchor"></a>Creating a sink</h2><p>Implementing custom sinks is useful to create a collection of reusable streaming consumers for your application.</p><p>The following example demonstrates a sink that consumes all elements into a list:</p><pre><code class="ml">let list_sink =
  let init () = [] in
  let push acc x = x :: acc in
  let stop acc = List.rev acc in
  Sink.make ~init ~push ~stop ()</code></pre><p>Alternatively, existing <a href="index.html#val-list"><code>list</code></a>/<a href="index.html#val-array"><code>array</code></a>/<a href="index.html#val-string"><code>string</code></a>/<a href="index.html#val-queue"><code>queue</code></a> sinks, or others listed below, can be used.</p></header><dl><dt class="spec value" id="val-fill"><a href="#val-fill" class="anchor"></a><code><span class="keyword">val</span> fill : <span class="type-var">'r</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r</span>)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>fill result</code> use <code>result</code> to fill the sink. This sink will not consume any input and will immediately produce <code>result</code> when used.</p></dd></dl><dl><dt class="spec value" id="val-fold"><a href="#val-fold" class="anchor"></a><code><span class="keyword">val</span> fold : <span>(<span class="type-var">'r</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'r</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'r</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r</span>)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>fold f init</code> is a sink that reduces all input elements with the stepping function <code>f</code> starting with the accumulator value <code>init</code>.</p></dd></dl><dl><dt class="spec value" id="val-fold_while"><a href="#val-fold_while" class="anchor"></a><code><span class="keyword">val</span> fold_while : <span>(<span class="type-var">'r</span> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span>(<span class="type-var">'r</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'r</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'r</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r</span>)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>fold_while full f init</code> is similar to <code>fold</code> but can terminate early if <code>full</code> returns <code>true</code>.</p></dd></dl><dl><dt class="spec value" id="val-make"><a href="#val-make" class="anchor"></a><code><span class="keyword">val</span> make : <span>init:<span>(unit <span>&#45;&gt;</span> <span class="type-var">'acc</span>)</span></span> <span>&#45;&gt;</span> <span>push:<span>(<span class="type-var">'acc</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'acc</span>)</span></span> <span>&#45;&gt;</span> <span>?&#8288;full:<span>(<span class="type-var">'acc</span> <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> <span>stop:<span>(<span class="type-var">'acc</span> <span>&#45;&gt;</span> <span class="type-var">'r</span>)</span></span> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r</span>)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p>Creates a sink from a function that <code>init</code>ializes a state value, a <code>step</code>ping function to update that state and a <code>stop</code> function that produces the final result value. Optionally a <code>full</code> function can be passed to decide when the sink should terminate early.</p><p><b>Note:</b> The calls to <code>full</code> should be cheap as this function will be called to avoid allocation of unnecessary resources. If the computation required to decide if the sink is full is expensive, consider caching it whenever possible.</p></dd></dl></section><section><header><h2 id="basic-sinks"><a href="#basic-sinks" class="anchor"></a>Basic sinks</h2></header><dl><dt class="spec value" id="val-full"><a href="#val-full" class="anchor"></a><code><span class="keyword">val</span> full : <span><span>(<span class="type-var">'a</span>, unit)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p>A full sink that will not consume any input and will not produce any results.</p></dd></dl><dl><dt class="spec value" id="val-is_empty"><a href="#val-is_empty" class="anchor"></a><code><span class="keyword">val</span> is_empty : <span><span>(<span class="type-var">'a</span>, bool)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>is_empty</code> is <code>true</code> if the sink did not consume any elements and <code>false</code> otherwise.</p></dd></dl><dl><dt class="spec value" id="val-each"><a href="#val-each" class="anchor"></a><code><span class="keyword">val</span> each : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, unit)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p>Applies an effectful action to all input elements producing nothing.</p></dd></dl><dl><dt class="spec value" id="val-len"><a href="#val-len" class="anchor"></a><code><span class="keyword">val</span> len : <span><span>(<span class="type-var">'a</span>, int)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p>Consumes and counts all input elements.</p></dd></dl><dl><dt class="spec value" id="val-first"><a href="#val-first" class="anchor"></a><code><span class="keyword">val</span> first : <span><span>(<span class="type-var">'a</span>, <span><span class="type-var">'a</span> option</span>)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p>The first input element, or <code>None</code> if the sink did not receive enough input.</p><p>Equivalent to <code>nth 0</code>.</p></dd></dl><dl><dt class="spec value" id="val-last"><a href="#val-last" class="anchor"></a><code><span class="keyword">val</span> last : <span><span>(<span class="type-var">'a</span>, <span><span class="type-var">'a</span> option</span>)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p>The last input element, or <code>None</code> if the sink did not receive enough input.</p></dd></dl><dl><dt class="spec value" id="val-nth"><a href="#val-nth" class="anchor"></a><code><span class="keyword">val</span> nth : int <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span><span class="type-var">'a</span> option</span>)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p>The n-th input element, or <code>None</code> if the sink did not receive enough input.</p></dd></dl><dl><dt class="spec value" id="val-drain"><a href="#val-drain" class="anchor"></a><code><span class="keyword">val</span> drain : <span><span>(<span class="type-var">'a</span>, unit)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p>Consumes all elements producing nothing. Useful for triggering actions in effectful streams.</p></dd></dl></section><section><header><h2 id="finding-elements"><a href="#finding-elements" class="anchor"></a>Finding elements</h2></header><dl><dt class="spec value" id="val-contains"><a href="#val-contains" class="anchor"></a><code><span class="keyword">val</span> contains : <span>where:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, bool)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>contains ~where:pred</code> finds the first element that satisfies <code>pred</code> returning <code>None</code> if there is no such element.</p></dd></dl><dl><dt class="spec value" id="val-find"><a href="#val-find" class="anchor"></a><code><span class="keyword">val</span> find : <span>where:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span><span class="type-var">'a</span> option</span>)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>find ~where:pred</code> finds the first element that satisfies <code>pred</code> returning <code>None</code> if there is no such element.</p></dd></dl><dl><dt class="spec value" id="val-index"><a href="#val-index" class="anchor"></a><code><span class="keyword">val</span> index : <span>where:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span>int option</span>)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p>Similar to <code>find</code> but returns the index of the element that satisfies the predicate.</p></dd></dl><dl><dt class="spec value" id="val-minimum"><a href="#val-minimum" class="anchor"></a><code><span class="keyword">val</span> minimum : <span>by:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span><span class="type-var">'a</span> option</span>)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p>Finds the minimum element in the sequence, using the given predicate as as the comparison between the input elements.</p></dd></dl><dl><dt class="spec value" id="val-maximum"><a href="#val-maximum" class="anchor"></a><code><span class="keyword">val</span> maximum : <span>by:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span><span class="type-var">'a</span> option</span>)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p>Finds the maximum element in the sequence, using the given predicate as as the comparison between the input elements.</p></dd></dl></section><section><header><h2 id="logical-predicates"><a href="#logical-predicates" class="anchor"></a>Logical predicates</h2></header><dl><dt class="spec value" id="val-all"><a href="#val-all" class="anchor"></a><code><span class="keyword">val</span> all : <span>where:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, bool)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>all ~where:pred</code> is <code>true</code> if all input element satisfy <code>pred</code>. Will stop consuming elements when the first element that does not satisfy <code>pred</code> is found. Results in <code>true</code> for empty input.</p></dd></dl><dl><dt class="spec value" id="val-any"><a href="#val-any" class="anchor"></a><code><span class="keyword">val</span> any : <span>where:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, bool)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>any ~where:pred</code> is <code>true</code> if at least one input element satisfies <code>pred</code>. Will stop consuming elements when such an element is found. Results in <code>false</code> for empty input.</p></dd></dl></section><section><header><h2 id="data-sinks"><a href="#data-sinks" class="anchor"></a>Data sinks</h2></header><dl><dt class="spec value" id="val-list"><a href="#val-list" class="anchor"></a><code><span class="keyword">val</span> list : <span><span>(<span class="type-var">'a</span>, <span><span class="type-var">'a</span> list</span>)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p>Puts all input elements into a list.</p></dd></dl><dl><dt class="spec value" id="val-array"><a href="#val-array" class="anchor"></a><code><span class="keyword">val</span> array : <span><span>(<span class="type-var">'a</span>, <span><span class="type-var">'a</span> array</span>)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p>Puts all input elements into an array.</p></dd></dl><dl><dt class="spec value" id="val-buffer"><a href="#val-buffer" class="anchor"></a><code><span class="keyword">val</span> buffer : int <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span><span class="type-var">'a</span> array</span>)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p>Similar to <a href="index.html#val-array"><code>array</code></a> buf will only consume <code>n</code> elements.</p></dd></dl><dl><dt class="spec value" id="val-queue"><a href="#val-queue" class="anchor"></a><code><span class="keyword">val</span> queue : <span><span>(<span class="type-var">'a</span>, <span><span class="type-var">'a</span> Stdlib.Queue.t</span>)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p>Puts all input elements into a queue.</p></dd></dl><dl><dt class="spec value" id="val-string"><a href="#val-string" class="anchor"></a><code><span class="keyword">val</span> string : <span><span>(string, string)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p>Consumes and concatenates strings.</p></dd></dl><dl><dt class="spec value" id="val-bytes"><a href="#val-bytes" class="anchor"></a><code><span class="keyword">val</span> bytes : <span><span>(bytes, bytes)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p>Consumes and concatenates bytes.</p></dd></dl></section><section><header><h2 id="io-sinks"><a href="#io-sinks" class="anchor"></a>IO sinks</h2></header><dl><dt class="spec value" id="val-print"><a href="#val-print" class="anchor"></a><code><span class="keyword">val</span> print : <span><span>(string, unit)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p>Prints all input string elements to standard output as lines.</p></dd></dl><dl><dt class="spec value" id="val-file"><a href="#val-file" class="anchor"></a><code><span class="keyword">val</span> file : string <span>&#45;&gt;</span> <span><span>(string, unit)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>file path</code> is a sink that writes input strings as lines into a file located at <code>path</code>.</p></dd></dl><dl><dt class="spec value" id="val-stdout"><a href="#val-stdout" class="anchor"></a><code><span class="keyword">val</span> stdout : <span><span>(string, unit)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p>A sink that writes input strings as lines to STDOUT.</p></dd></dl><dl><dt class="spec value" id="val-stderr"><a href="#val-stderr" class="anchor"></a><code><span class="keyword">val</span> stderr : <span><span>(string, unit)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p>A sink that writes input strings as lines to STDERR.</p></dd></dl></section><section><header><h2 id="numeric-computations"><a href="#numeric-computations" class="anchor"></a>Numeric computations</h2></header><dl><dt class="spec value" id="val-sum"><a href="#val-sum" class="anchor"></a><code><span class="keyword">val</span> sum : <span><span>(int, int)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p>Adds all input integer values.</p></dd></dl><dl><dt class="spec value" id="val-product"><a href="#val-product" class="anchor"></a><code><span class="keyword">val</span> product : <span><span>(int, int)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p>Product of input integer values. Stops if any input element is <code>0</code>.</p></dd></dl><dl><dt class="spec value" id="val-mean"><a href="#val-mean" class="anchor"></a><code><span class="keyword">val</span> mean : <span><span>(float, float)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p>Computes a numerically stable arithmetic mean of all input elements.</p></dd></dl></section><section><header><h2 id="combining-sinks"><a href="#combining-sinks" class="anchor"></a>Combining sinks</h2></header><dl><dt class="spec value" id="val-zip"><a href="#val-zip" class="anchor"></a><code><span class="keyword">val</span> zip : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r1</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r2</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r1</span> * <span class="type-var">'r2</span>)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>zip left right</code> computes both <code>left</code> and <code>right</code> at the same time with the same input being sent to both sinks. The results of both sinks are produced.</p></dd></dl><dl><dt class="spec value" id="val-zip_left"><a href="#val-zip_left" class="anchor"></a><code><span class="keyword">val</span> zip_left : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">_</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r</span>)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>zip_left left right</code> similar to <a href="index.html#val-zip"><code>zip</code></a>, but only produces the result of the <code>left</code> sink.</p></dd></dl><dl><dt class="spec value" id="val-zip_right"><a href="#val-zip_right" class="anchor"></a><code><span class="keyword">val</span> zip_right : <span><span>(<span class="type-var">'a</span>, <span class="type-var">_</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r</span>)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>zip_left left right</code> similar to <a href="index.html#val-zip"><code>zip</code></a>, but only produces the result of the <code>right</code> sink.</p></dd></dl><dl><dt class="spec value" id="val-zip_with"><a href="#val-zip_with" class="anchor"></a><code><span class="keyword">val</span> zip_with : <span>(<span class="type-var">'r1</span> <span>&#45;&gt;</span> <span class="type-var">'r2</span> <span>&#45;&gt;</span> <span class="type-var">'r</span>)</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r1</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r2</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r</span>)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>zip_with f left right</code> similar to <a href="index.html#val-zip"><code>zip</code></a>, but applies an aggregation function to results produced by <code>left</code> and <code>right</code>.</p></dd></dl><dl><dt class="spec value" id="val-(&lt;&amp;&gt;)"><a href="#val-(&lt;&amp;&gt;)" class="anchor"></a><code><span class="keyword">val</span> (&lt;&amp;&gt;) : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r1</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r2</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r1</span> * <span class="type-var">'r2</span>)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>left &lt;&amp;&gt; right</code> is an operator version of <code>zip left right</code>.</p></dd></dl><dl><dt class="spec value" id="val-(&lt;&amp;)"><a href="#val-(&lt;&amp;)" class="anchor"></a><code><span class="keyword">val</span> (&lt;&amp;) : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">_</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r</span>)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>left &lt;&amp; right</code> is an operator version of <code>zip_left left right</code>.</p></dd></dl><dl><dt class="spec value" id="val-(&amp;&gt;)"><a href="#val-(&amp;&gt;)" class="anchor"></a><code><span class="keyword">val</span> (&amp;&gt;) : <span><span>(<span class="type-var">'a</span>, <span class="type-var">_</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r</span>)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>left &amp;&gt; right</code> is an operator version of <code>zip_right left right</code>.</p></dd></dl><dl><dt class="spec value" id="val-unzip"><a href="#val-unzip" class="anchor"></a><code><span class="keyword">val</span> unzip : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r1</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'b</span>, <span class="type-var">'r2</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>, <span class="type-var">'r1</span> * <span class="type-var">'r2</span>)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>unzip left right</code> is a sink that receives pairs <code>'a * 'b</code>, sending the first element into <code>left</code> and the second into <code>right</code>. Both sinks are computed at the same time and their results returned as an output pair.</p><p>The sink becomes full when either <code>left</code> or <code>right</code> get full.</p></dd></dl><dl><dt class="spec value" id="val-unzip_left"><a href="#val-unzip_left" class="anchor"></a><code><span class="keyword">val</span> unzip_left : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'b</span>, <span class="type-var">_</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>, <span class="type-var">'r</span>)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>unzip_left left right</code> is similar to <a href="index.html#val-unzip"><code>unzip</code></a>, but only produces the result of the <code>left</code> sink.</p><p>If <code>right</code> terminates first, <code>left</code> will be forced to terminate.</p></dd></dl><dl><dt class="spec value" id="val-unzip_right"><a href="#val-unzip_right" class="anchor"></a><code><span class="keyword">val</span> unzip_right : <span><span>(<span class="type-var">'a</span>, <span class="type-var">_</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'b</span>, <span class="type-var">'r</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>, <span class="type-var">'r</span>)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>unzip_left left right</code> is similar to <a href="index.html#val-unzip"><code>unzip</code></a>, but only produces the result of the <code>right</code> sink.</p><p>If <code>left</code> terminates first, <code>right</code> will be forced to terminate.</p></dd></dl><dl><dt class="spec value" id="val-unzip_with"><a href="#val-unzip_with" class="anchor"></a><code><span class="keyword">val</span> unzip_with : <span>(<span class="type-var">'r1</span> <span>&#45;&gt;</span> <span class="type-var">'r2</span> <span>&#45;&gt;</span> <span class="type-var">'r</span>)</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r1</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'b</span>, <span class="type-var">'r2</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>, <span class="type-var">'r</span>)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>unzip_with f left right</code> similar to <a href="index.html#val-unzip"><code>unzip</code></a>, but applies an aggregation function to results produced by <code>left</code> and <code>right</code>.</p></dd></dl><dl><dt class="spec value" id="val-(&lt;*&gt;)"><a href="#val-(&lt;*&gt;)" class="anchor"></a><code><span class="keyword">val</span> (&lt;*&gt;) : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r1</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'b</span>, <span class="type-var">'r2</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>, <span class="type-var">'r1</span> * <span class="type-var">'r2</span>)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>left &lt;*&gt; right</code> is an operator version of <code>unzip left right</code>.</p></dd></dl><dl><dt class="spec value" id="val-(&lt;*)"><a href="#val-(&lt;*)" class="anchor"></a><code><span class="keyword">val</span> (&lt;*) : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'b</span>, <span class="type-var">_</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>, <span class="type-var">'r</span>)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>left &lt;* right</code> is an operator version of <code>unzip_left left right</code>.</p></dd></dl><dl><dt class="spec value" id="val-(*&gt;)"><a href="#val-(*&gt;)" class="anchor"></a><code><span class="keyword">val</span> (*&gt;) : <span><span>(<span class="type-var">'a</span>, <span class="type-var">_</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'b</span>, <span class="type-var">'r</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>, <span class="type-var">'r</span>)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>left *&gt; right</code> is an operator version of <code>unzip_right left right</code>.</p></dd></dl><dl><dt class="spec value" id="val-distribute"><a href="#val-distribute" class="anchor"></a><code><span class="keyword">val</span> distribute : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r1</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r2</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r1</span> * <span class="type-var">'r2</span>)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>distribute left right</code> is similar to <code>zip</code> but distributes the consumed elements over <code>left</code> and <code>right</code> alternating in a round robin fashion.</p></dd></dl><dl><dt class="spec type" id="type-race"><a href="#type-race" class="anchor"></a><code><span class="keyword">type</span> <span>('a, 'b) race</span></code><code> = </code><table class="variant"><tr id="type-race.Left" class="anchored"><td class="def constructor"><a href="#type-race.Left" class="anchor"></a><code>| </code><code><span class="constructor">Left</span> <span class="keyword">of</span> <span class="type-var">'a</span></code></td></tr><tr id="type-race.Right" class="anchored"><td class="def constructor"><a href="#type-race.Right" class="anchor"></a><code>| </code><code><span class="constructor">Right</span> <span class="keyword">of</span> <span class="type-var">'b</span></code></td></tr><tr id="type-race.Both" class="anchored"><td class="def constructor"><a href="#type-race.Both" class="anchor"></a><code>| </code><code><span class="constructor">Both</span> <span class="keyword">of</span> <span class="type-var">'a</span> * <span class="type-var">'b</span></code></td></tr></table></dt><dd><p>Type for <a href="index.html#val-race"><code>race</code></a> result values.</p></dd></dl><dl><dt class="spec value" id="val-race"><a href="#val-race" class="anchor"></a><code><span class="keyword">val</span> race : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r1</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r2</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span><span>(<span class="type-var">'r1</span>, <span class="type-var">'r2</span>)</span> <a href="index.html#type-race">race</a></span>)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>race left right</code> runs both <code>left</code> and <code>right</code> sinks at the same time producing the result for the one that fills first.</p><p>If the sink is terminated prematurely, before either <code>left</code> or <code>right</code> are filled, <a href="#type-race.Both"><code>Both</code></a> of their values are produced.</p><h5 id="examples"><a href="#examples" class="anchor"></a>Examples</h5><pre><code class="ml">let sink = Sink.(race (find ~where:(fun x -&gt; x &gt; 10)) (nth 8)) in
let result = Stream.of_list [1; 9; 0; 8; 30; 4] |&gt; Stream.into sink in
assert (result = Sink.Left (Some 30))</code></pre></dd></dl><dl><dt class="spec value" id="val-(&lt;|&gt;)"><a href="#val-(&lt;|&gt;)" class="anchor"></a><code><span class="keyword">val</span> (&lt;|&gt;) : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r1</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r2</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span><span>(<span class="type-var">'r1</span>, <span class="type-var">'r2</span>)</span> <a href="index.html#type-race">race</a></span>)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>left &lt;|&gt; right</code> is the operator version of <code>race left right</code>.</p></dd></dl><dl><dt class="spec value" id="val-seq"><a href="#val-seq" class="anchor"></a><code><span class="keyword">val</span> seq : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r1</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r2</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r1</span> * <span class="type-var">'r2</span>)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>seq left right</code> runs <code>left</code> and then <code>right</code> sequentially producing both of their results.</p><p>If the resulting sink is stopped before <code>right</code> was started, it will be forced to initialize and terminate.</p></dd></dl><dl><dt class="spec value" id="val-seq_left"><a href="#val-seq_left" class="anchor"></a><code><span class="keyword">val</span> seq_left : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">_</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r</span>)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>seq_left left right</code> is similar to <code>seq</code>, but only produces the result of the <code>left</code> sink.</p></dd></dl><dl><dt class="spec value" id="val-seq_right"><a href="#val-seq_right" class="anchor"></a><code><span class="keyword">val</span> seq_right : <span><span>(<span class="type-var">'a</span>, <span class="type-var">_</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r</span>)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>seq_right left right</code> is similar to <code>seq</code>, but only produces the result of the <code>right</code> sink.</p></dd></dl><dl><dt class="spec value" id="val-(&lt;+&gt;)"><a href="#val-(&lt;+&gt;)" class="anchor"></a><code><span class="keyword">val</span> (&lt;+&gt;) : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r1</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r2</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r1</span> * <span class="type-var">'r2</span>)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>left &lt;+&gt; right</code> is an operator version of <code>seq left right</code>.</p></dd></dl><dl><dt class="spec value" id="val-(&lt;+)"><a href="#val-(&lt;+)" class="anchor"></a><code><span class="keyword">val</span> (&lt;+) : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">_</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r</span>)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>left &lt;+ right</code> is an operator version of <code>seq_left left right</code>.</p></dd></dl><dl><dt class="spec value" id="val-(+&gt;)"><a href="#val-(+&gt;)" class="anchor"></a><code><span class="keyword">val</span> (+&gt;) : <span><span>(<span class="type-var">'a</span>, <span class="type-var">_</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r</span>)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>left +&gt; right</code> is an operator version of <code>seq_right left right</code>.</p></dd></dl><dl><dt class="spec value" id="val-flat_map"><a href="#val-flat_map" class="anchor"></a><code><span class="keyword">val</span> flat_map : <span>(<span class="type-var">'r1</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r2</span>)</span> <a href="index.html#type-t">t</a></span>)</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r1</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r2</span>)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>flat_map f sink</code> is a sink produced by applying the result of <code>sink</code> to <code>f</code>. This allows to sequence multiple sinks by inspecting the result value produced by the previous sinks.</p><p><code>flat_map</code> is defined as the <code>let*</code> operator in <a href="Syntax/index.html"><code>Syntax</code></a>.</p><p><b>Note:</b> If <code>sink</code> is terminated exhausting the entire input, the sink produced by <code>f</code> will be initialized and immediately forced to terminate.</p><pre><code class="ml"># let large_values () = Sink.flat_map
    (function
      | Some x -&gt; Printf.printf &quot;Found value: %d\n&quot; x; Sink.list
      | None -&gt; Printf.printf &quot;No value found\n&quot;; Sink.fill [])
    (Sink.find ~where:(fun x -&gt; x &gt; 100))
val sink1 : unit -&gt; (int, int list) sink = &lt;fun&gt;

# let values = Stream.(90 -&lt; 105) |&gt; Stream.into (sink1 ())
Found value: 101
val values : int list = [102; 103; 104]</code></pre></dd></dl><dl><dt class="spec value" id="val-(&gt;&gt;=)"><a href="#val-(&gt;&gt;=)" class="anchor"></a><code><span class="keyword">val</span> (&gt;&gt;=) : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r1</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>(<span class="type-var">'r1</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r2</span>)</span> <a href="index.html#type-t">t</a></span>)</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r2</span>)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>sink &gt;&gt;= f</code> is an operator version of <code>flat_map f sink</code>.</p></dd></dl></section><section><header><h2 id="mapping-and-filtering-sinks"><a href="#mapping-and-filtering-sinks" class="anchor"></a>Mapping and filtering sinks</h2></header><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : <span>(<span class="type-var">'r1</span> <span>&#45;&gt;</span> <span class="type-var">'r2</span>)</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r1</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r2</span>)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>map f sink</code> is a sink <code>sink</code> with the result transformed with <code>f</code>.</p></dd></dl><dl><dt class="spec value" id="val-(&lt;@&gt;)"><a href="#val-(&lt;@&gt;)" class="anchor"></a><code><span class="keyword">val</span> (&lt;@&gt;) : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'c</span>, <span class="type-var">'a</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'c</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>f &lt;@&gt; sink</code> is the operator version of <code>map f sink</code>.</p></dd></dl><dl><dt class="spec value" id="val-premap"><a href="#val-premap" class="anchor"></a><code><span class="keyword">val</span> premap : <span>(<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'b</span>, <span class="type-var">'r</span>)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>premap f sink</code> is a sink that <em>premaps</em> the input values.</p><h5 id="examples"><a href="#examples" class="anchor"></a>Examples</h5><p>If <code>sink</code> consumes integers, but we have an input with strings, we can provide a conversion from strings to integers to <code>premap</code>:</p><pre><code class="ml">let sink = Sink.(premap int_of_string sum) in
let result = Stream.of_list [&quot;1&quot;; &quot;2&quot;; &quot;3&quot;] |&gt; Stream.into sink in
assert (result = 6)</code></pre></dd></dl><dl><dt class="spec value" id="val-prefilter"><a href="#val-prefilter" class="anchor"></a><code><span class="keyword">val</span> prefilter : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r</span>)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>prefilter predicate sink</code> is a sink that filter the input value for <code>sink</code>.</p></dd></dl><dl><dt class="spec value" id="val-prefilter_map"><a href="#val-prefilter_map" class="anchor"></a><code><span class="keyword">val</span> prefilter_map : <span>(<span class="type-var">'b</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> option</span>)</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'b</span>, <span class="type-var">'r</span>)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>prefilter_map f sink</code> applies <code>f</code> to every input value <code>x</code> of sink, discarding it if <code>f x</code> produces <code>None</code>, and keeping the transformed value otherwise.</p></dd></dl></section><section><header><h2 id="resource-management"><a href="#resource-management" class="anchor"></a>Resource management</h2></header><dl><dt class="spec value" id="val-dispose"><a href="#val-dispose" class="anchor"></a><code><span class="keyword">val</span> dispose : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span class="type-var">'r</span></code></dt><dd><p>Close the sink and produce the currently accumulated result. Any internal state will be terminated.</p></dd></dl></section><section><header><h2 id="syntax-definitions"><a href="#syntax-definitions" class="anchor"></a>Syntax definitions</h2><p>In addition to using the sinks and operations defined above, it is possible to create sinks with a convenient <code>(let)</code> notation.</p><p>A common example of a composed sink is the sink that computes the arithmetic mean:</p><pre><code class="ml">let mean =
  let open Sink.Syntax in
  let+ total = Sink.sum
  and+ count = Sink.len in
  total / count</code></pre><p>The resulting sink has type <code>(int, int) sink</code> and will only consume the input once!</p></header><dl><dt class="spec module" id="module-Syntax"><a href="#module-Syntax" class="anchor"></a><code><span class="keyword">module</span> <a href="Syntax/index.html">Syntax</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Module with syntax definitions for sinks.</p></dd></dl></section><section><header><h2 id="interface-implementations"><a href="#interface-implementations" class="anchor"></a>Interface implementations</h2></header><dl><dt class="spec module" id="module-Functor"><a href="#module-Functor" class="anchor"></a><code><span class="keyword">module</span> <a href="Functor/index.html">Functor</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Module that implements the &quot;Functor&quot; interface.</p></dd></dl><dl><dt class="spec module" id="module-Applicative"><a href="#module-Applicative" class="anchor"></a><code><span class="keyword">module</span> <a href="Applicative/index.html">Applicative</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Module that implements the &quot;Applicative&quot; interface.</p></dd></dl></section></div></body></html>