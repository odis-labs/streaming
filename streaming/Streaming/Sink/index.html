<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Sink (streaming.Streaming.Sink)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../../index.html">streaming</a> &#x00BB; <a href="../index.html">Streaming</a> &#x00BB; Sink</nav><header class="odoc-preamble"><h1>Module <code><span>Streaming.Sink</span></code></h1><p>Module with defintions for sinks.</p><p>Sinks are streaming abstractions that consume values and produce an aggregated value as a result. The result value is extracted from an internal state that is built incrementally. The internal state can aquire resources that are guaranteed to be terminated when the sink is filled.</p><p>Sinks are a great way to define decoupled consumers that can be filled with <a href="../Stream/index.html#val-into"><code>Stream.into</code></a>.</p><p>Sinks are independent from sources and streams. You can think of them as packed arguments for folding functions with early termination. Formally, they can also be interpreted as <a href="https://en.wikipedia.org/wiki/Moore_machine">Moore machine</a>.</p></header><nav class="odoc-toc"><ul><li><a href="#creating-a-sink">Creating a sink</a></li><li><a href="#basic-sinks">Basic sinks</a></li><li><a href="#finding-elements">Finding elements</a></li><li><a href="#logical-predicates">Logical predicates</a></li><li><a href="#data-sinks">Data sinks</a></li><li><a href="#io-sinks">IO sinks</a></li><li><a href="#numeric-computations">Numeric computations</a></li><li><a href="#combining-sinks">Combining sinks</a></li><li><a href="#mapping-and-filtering-sinks">Mapping and filtering sinks</a></li><li><a href="#resource-management">Resource management</a></li><li><a href="#syntax-definitions">Syntax definitions</a></li><li><a href="#interface-implementations">Interface implementations</a></li></ul></nav><div class="odoc-content"><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>('a, 'b) t</span></span><span> = <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="../index.html#type-sink">sink</a></span></span></code></div><div class="spec-doc"><p>Type for sinks that consume elements of type <code>'a</code> and, once done, produce a value of type <code>'b</code>.</p></div></div><h2 id="creating-a-sink"><a href="#creating-a-sink" class="anchor"></a>Creating a sink</h2><p>Implementing custom sinks is useful to create a collection of reusable streaming consumers for your application.</p><p>The following example demonstrates a sink that consumes all elements into a list:</p><pre><code>let list_sink =
  let init () = [] in
  let push acc x = x :: acc in
  let stop acc = List.rev acc in
  Sink.make ~init ~push ~stop ()</code></pre><p>Alternatively, existing <a href="#val-list"><code>list</code></a>/<a href="#val-array"><code>array</code></a>/<a href="#val-string"><code>string</code></a>/<a href="#val-queue"><code>queue</code></a> sinks, or others listed below, can be used.</p><div class="odoc-spec"><div class="spec value" id="val-fill" class="anchored"><a href="#val-fill" class="anchor"></a><code><span><span class="keyword">val</span> fill : <span><span class="type-var">'r</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>fill result</code> use <code>result</code> to fill the sink. This sink will not consume any input and will immediately produce <code>result</code> when used.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fold" class="anchored"><a href="#val-fold" class="anchor"></a><code><span><span class="keyword">val</span> fold : <span><span>(<span><span class="type-var">'r</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'r</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'r</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>fold f init</code> is a sink that reduces all input elements with the stepping function <code>f</code> starting with the accumulator value <code>init</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fold_while" class="anchored"><a href="#val-fold_while" class="anchor"></a><code><span><span class="keyword">val</span> fold_while : <span><span>(<span><span class="type-var">'r</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'r</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'r</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'r</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>fold_while full f init</code> is similar to <code>fold</code> but can terminate early if <code>full</code> returns <code>true</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-make" class="anchored"><a href="#val-make" class="anchor"></a><code><span><span class="keyword">val</span> make : <span>init:<span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'acc</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span>push:<span>(<span><span class="type-var">'acc</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'acc</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span>?full:<span>(<span><span class="type-var">'acc</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span>
<span>stop:<span>(<span><span class="type-var">'acc</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'r</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Creates a sink from a function that <code>init</code>ializes a state value, a <code>step</code>ping function to update that state and a <code>stop</code> function that produces the final result value. Optionally a <code>full</code> function can be passed to decide when the sink should terminate early.</p><p><b>Note:</b> The calls to <code>full</code> should be cheap as this function will be called to avoid allocation of unnecessary resources. If the computation required to decide if the sink is full is expensive, consider caching it whenever possible.</p></div></div><h2 id="basic-sinks"><a href="#basic-sinks" class="anchor"></a>Basic sinks</h2><div class="odoc-spec"><div class="spec value" id="val-full" class="anchored"><a href="#val-full" class="anchor"></a><code><span><span class="keyword">val</span> full : <span><span>(<span class="type-var">'a</span>, unit)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>A full sink that will not consume any input and will not produce any results.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-is_full" class="anchored"><a href="#val-is_full" class="anchor"></a><code><span><span class="keyword">val</span> is_full : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'r</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_full sink</code> is <code>true</code> if <code>sink</code> is full. Full sinks do not consume any elements but will be initialised to determine if they are full.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-is_empty" class="anchored"><a href="#val-is_empty" class="anchor"></a><code><span><span class="keyword">val</span> is_empty : <span><span>(<span class="type-var">'a</span>, bool)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>is_empty</code> is a sink that produces <code>true</code> when it is stopped without consuming any elements.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-push" class="anchored"><a href="#val-push" class="anchor"></a><code><span><span class="keyword">val</span> push : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'r</span>)</span> <a href="../index.html#type-sink">sink</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r</span>)</span> <a href="../index.html#type-sink">sink</a></span></span></code></div><div class="spec-doc"><p><code>push x sink</code> updates <code>sink</code>'s internal state by pushing <code>x</code> into it. The internal sink's state will be initialised.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-each" class="anchored"><a href="#val-each" class="anchor"></a><code><span><span class="keyword">val</span> each : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, unit)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Applies an effectful action to all input elements producing nothing.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-len" class="anchored"><a href="#val-len" class="anchor"></a><code><span><span class="keyword">val</span> len : <span><span>(<span class="type-var">'a</span>, int)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Consumes and counts all input elements.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-first" class="anchored"><a href="#val-first" class="anchor"></a><code><span><span class="keyword">val</span> first : <span><span>(<span class="type-var">'a</span>, <span><span class="type-var">'a</span> option</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>The first input element, or <code>None</code> if the sink did not receive enough input.</p><p>Equivalent to <code>nth 0</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-last" class="anchored"><a href="#val-last" class="anchor"></a><code><span><span class="keyword">val</span> last : <span><span>(<span class="type-var">'a</span>, <span><span class="type-var">'a</span> option</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>The last input element, or <code>None</code> if the sink did not receive enough input.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-nth" class="anchored"><a href="#val-nth" class="anchor"></a><code><span><span class="keyword">val</span> nth : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span><span class="type-var">'a</span> option</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>The n-th input element, or <code>None</code> if the sink did not receive enough input.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-drain" class="anchored"><a href="#val-drain" class="anchor"></a><code><span><span class="keyword">val</span> drain : <span><span>(<span class="type-var">'a</span>, unit)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Consumes all elements producing nothing. Useful for triggering actions in effectful streams.</p></div></div><h2 id="finding-elements"><a href="#finding-elements" class="anchor"></a>Finding elements</h2><div class="odoc-spec"><div class="spec value" id="val-contains" class="anchored"><a href="#val-contains" class="anchor"></a><code><span><span class="keyword">val</span> contains : <span>where:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, bool)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>contains ~where:pred</code> finds the first element that satisfies <code>pred</code> returning <code>None</code> if there is no such element.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-find" class="anchored"><a href="#val-find" class="anchor"></a><code><span><span class="keyword">val</span> find : <span>where:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span><span class="type-var">'a</span> option</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>find ~where:pred</code> finds the first element that satisfies <code>pred</code> returning <code>None</code> if there is no such element.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-index" class="anchored"><a href="#val-index" class="anchor"></a><code><span><span class="keyword">val</span> index : <span>where:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span>int option</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Similar to <code>find</code> but returns the index of the element that satisfies the predicate.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-minimum" class="anchored"><a href="#val-minimum" class="anchor"></a><code><span><span class="keyword">val</span> minimum : <span>by:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span><span class="type-var">'a</span> option</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Finds the minimum element in the sequence, using the given predicate as as the comparison between the input elements.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-maximum" class="anchored"><a href="#val-maximum" class="anchor"></a><code><span><span class="keyword">val</span> maximum : <span>by:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span><span class="type-var">'a</span> option</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Finds the maximum element in the sequence, using the given predicate as as the comparison between the input elements.</p></div></div><h2 id="logical-predicates"><a href="#logical-predicates" class="anchor"></a>Logical predicates</h2><div class="odoc-spec"><div class="spec value" id="val-all" class="anchored"><a href="#val-all" class="anchor"></a><code><span><span class="keyword">val</span> all : <span>where:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, bool)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>all ~where:pred</code> is <code>true</code> if all input element satisfy <code>pred</code>. Will stop consuming elements when the first element that does not satisfy <code>pred</code> is found. Results in <code>true</code> for empty input.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-any" class="anchored"><a href="#val-any" class="anchor"></a><code><span><span class="keyword">val</span> any : <span>where:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, bool)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>any ~where:pred</code> is <code>true</code> if at least one input element satisfies <code>pred</code>. Will stop consuming elements when such an element is found. Results in <code>false</code> for empty input.</p></div></div><h2 id="data-sinks"><a href="#data-sinks" class="anchor"></a>Data sinks</h2><div class="odoc-spec"><div class="spec value" id="val-list" class="anchored"><a href="#val-list" class="anchor"></a><code><span><span class="keyword">val</span> list : <span><span>(<span class="type-var">'a</span>, <span><span class="type-var">'a</span> list</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Puts all input elements into a list.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-list_rev" class="anchored"><a href="#val-list_rev" class="anchor"></a><code><span><span class="keyword">val</span> list_rev : <span><span>(<span class="type-var">'a</span>, <span><span class="type-var">'a</span> list</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Puts all input elements into a list in the reverse order. Faster than <a href="#val-list"><code>list</code></a> as no reveral is performed.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-array" class="anchored"><a href="#val-array" class="anchor"></a><code><span><span class="keyword">val</span> array : <span><span>(<span class="type-var">'a</span>, <span><span class="type-var">'a</span> array</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Puts all input elements into an array.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-buffer" class="anchored"><a href="#val-buffer" class="anchor"></a><code><span><span class="keyword">val</span> buffer : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span><span class="type-var">'a</span> array</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Similar to <a href="#val-array"><code>array</code></a> buf will only consume <code>n</code> elements.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-queue" class="anchored"><a href="#val-queue" class="anchor"></a><code><span><span class="keyword">val</span> queue : <span><span>(<span class="type-var">'a</span>, <span><span class="type-var">'a</span> <span class="xref-unresolved">Stdlib</span>.Queue.t</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Puts all input elements into a queue.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-string" class="anchored"><a href="#val-string" class="anchor"></a><code><span><span class="keyword">val</span> string : <span><span>(string, string)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Consumes and concatenates strings.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-bytes" class="anchored"><a href="#val-bytes" class="anchor"></a><code><span><span class="keyword">val</span> bytes : <span><span>(bytes, bytes)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Consumes and concatenates bytes.</p></div></div><h2 id="io-sinks"><a href="#io-sinks" class="anchor"></a>IO sinks</h2><div class="odoc-spec"><div class="spec value" id="val-print" class="anchored"><a href="#val-print" class="anchor"></a><code><span><span class="keyword">val</span> print : <span><span>(string, unit)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Prints all input string elements to standard output as lines.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-file" class="anchored"><a href="#val-file" class="anchor"></a><code><span><span class="keyword">val</span> file : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span>(string, unit)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>file path</code> is a sink that writes input strings as lines into a file located at <code>path</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-stdout" class="anchored"><a href="#val-stdout" class="anchor"></a><code><span><span class="keyword">val</span> stdout : <span><span>(string, unit)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>A sink that writes input strings as lines to STDOUT.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-stderr" class="anchored"><a href="#val-stderr" class="anchor"></a><code><span><span class="keyword">val</span> stderr : <span><span>(string, unit)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>A sink that writes input strings as lines to STDERR.</p></div></div><h2 id="numeric-computations"><a href="#numeric-computations" class="anchor"></a>Numeric computations</h2><div class="odoc-spec"><div class="spec value" id="val-sum" class="anchored"><a href="#val-sum" class="anchor"></a><code><span><span class="keyword">val</span> sum : <span><span>(int, int)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Adds all input integer values.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-product" class="anchored"><a href="#val-product" class="anchor"></a><code><span><span class="keyword">val</span> product : <span><span>(int, int)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Product of input integer values. Stops if any input element is <code>0</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mean" class="anchored"><a href="#val-mean" class="anchor"></a><code><span><span class="keyword">val</span> mean : <span><span>(float, float)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Computes a numerically stable arithmetic mean of all input elements.</p></div></div><h2 id="combining-sinks"><a href="#combining-sinks" class="anchor"></a>Combining sinks</h2><div class="odoc-spec"><div class="spec value" id="val-zip" class="anchored"><a href="#val-zip" class="anchor"></a><code><span><span class="keyword">val</span> zip : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'r1</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'r2</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r1</span> * <span class="type-var">'r2</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>zip left right</code> computes both <code>left</code> and <code>right</code> at the same time with the same input being sent to both sinks. The results of both sinks are produced.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-both" class="anchored"><a href="#val-both" class="anchor"></a><code><span><span class="keyword">val</span> both : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'r1</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'r2</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r1</span> * <span class="type-var">'r2</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>both left right</code> computes both <code>left</code> and <code>right</code> at the same time with the same input. Alias for <a href="#val-zip"><code>zip</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-zip_left" class="anchored"><a href="#val-zip_left" class="anchor"></a><code><span><span class="keyword">val</span> zip_left : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'r</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">_</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>zip_left left right</code> similar to <a href="#val-zip"><code>zip</code></a>, but only produces the result of the <code>left</code> sink.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-zip_right" class="anchored"><a href="#val-zip_right" class="anchor"></a><code><span><span class="keyword">val</span> zip_right : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">_</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'r</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>zip_left left right</code> similar to <a href="#val-zip"><code>zip</code></a>, but only produces the result of the <code>right</code> sink.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-zip_with" class="anchored"><a href="#val-zip_with" class="anchor"></a><code><span><span class="keyword">val</span> zip_with : <span><span>(<span><span class="type-var">'r1</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'r2</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'r</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'r1</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'r2</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>zip_with f left right</code> similar to <a href="#val-zip"><code>zip</code></a>, but applies an aggregation function to results produced by <code>left</code> and <code>right</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-(&lt;&amp;&gt;)" class="anchored"><a href="#val-(&lt;&amp;&gt;)" class="anchor"></a><code><span><span class="keyword">val</span> (&lt;&amp;&gt;) : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'r1</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'r2</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r1</span> * <span class="type-var">'r2</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>left &lt;&amp;&gt; right</code> is an operator version of <code>zip left right</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-(&lt;&amp;)" class="anchored"><a href="#val-(&lt;&amp;)" class="anchor"></a><code><span><span class="keyword">val</span> (&lt;&amp;) : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'r</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">_</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>left &lt;&amp; right</code> is an operator version of <code>zip_left left right</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-(&amp;&gt;)" class="anchored"><a href="#val-(&amp;&gt;)" class="anchor"></a><code><span><span class="keyword">val</span> (&amp;&gt;) : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">_</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'r</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>left &amp;&gt; right</code> is an operator version of <code>zip_right left right</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-many" class="anchored"><a href="#val-many" class="anchor"></a><code><span><span class="keyword">val</span> many : <span><span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'r</span>)</span> <a href="#type-t">t</a></span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span><span class="type-var">'r</span> list</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>many sinks</code> computes all <code>sinks</code> at the same time with the same input. All <code>sinks</code> must have produce the same result type.</p><p>The sinks will be computed until all sinks are full or until the sink is stopped explicitly.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-unzip" class="anchored"><a href="#val-unzip" class="anchor"></a><code><span><span class="keyword">val</span> unzip : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'r1</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'b</span>, <span class="type-var">'r2</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>, <span class="type-var">'r1</span> * <span class="type-var">'r2</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>unzip left right</code> is a sink that receives pairs <code>'a * 'b</code>, sending the first element into <code>left</code> and the second into <code>right</code>. Both sinks are computed at the same time and their results returned as an output pair.</p><p>The sink becomes full when either <code>left</code> or <code>right</code> get full.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-unzip_left" class="anchored"><a href="#val-unzip_left" class="anchor"></a><code><span><span class="keyword">val</span> unzip_left : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'r</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'b</span>, <span class="type-var">_</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>, <span class="type-var">'r</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>unzip_left left right</code> is similar to <a href="#val-unzip"><code>unzip</code></a>, but only produces the result of the <code>left</code> sink.</p><p>If <code>right</code> terminates first, <code>left</code> will be forced to terminate.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-unzip_right" class="anchored"><a href="#val-unzip_right" class="anchor"></a><code><span><span class="keyword">val</span> unzip_right : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">_</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'b</span>, <span class="type-var">'r</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>, <span class="type-var">'r</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>unzip_left left right</code> is similar to <a href="#val-unzip"><code>unzip</code></a>, but only produces the result of the <code>right</code> sink.</p><p>If <code>left</code> terminates first, <code>right</code> will be forced to terminate.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-unzip_with" class="anchored"><a href="#val-unzip_with" class="anchor"></a><code><span><span class="keyword">val</span> unzip_with : <span><span>(<span><span class="type-var">'r1</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'r2</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'r</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'r1</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'b</span>, <span class="type-var">'r2</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>, <span class="type-var">'r</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>unzip_with f left right</code> similar to <a href="#val-unzip"><code>unzip</code></a>, but applies an aggregation function to results produced by <code>left</code> and <code>right</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-(&lt;*&gt;)" class="anchored"><a href="#val-(&lt;*&gt;)" class="anchor"></a><code><span><span class="keyword">val</span> (&lt;*&gt;) : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'r1</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'b</span>, <span class="type-var">'r2</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>, <span class="type-var">'r1</span> * <span class="type-var">'r2</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>left &lt;*&gt; right</code> is an operator version of <code>unzip left right</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-(&lt;*)" class="anchored"><a href="#val-(&lt;*)" class="anchor"></a><code><span><span class="keyword">val</span> (&lt;*) : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'r</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'b</span>, <span class="type-var">_</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>, <span class="type-var">'r</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>left &lt;* right</code> is an operator version of <code>unzip_left left right</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-(*&gt;)" class="anchored"><a href="#val-(*&gt;)" class="anchor"></a><code><span><span class="keyword">val</span> (*&gt;) : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">_</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'b</span>, <span class="type-var">'r</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>, <span class="type-var">'r</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>left *&gt; right</code> is an operator version of <code>unzip_right left right</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-distribute" class="anchored"><a href="#val-distribute" class="anchor"></a><code><span><span class="keyword">val</span> distribute : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'r1</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'r2</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r1</span> * <span class="type-var">'r2</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>distribute left right</code> is similar to <code>zip</code> but distributes the consumed elements over <code>left</code> and <code>right</code> alternating in a round robin fashion.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-race" class="anchored"><a href="#type-race" class="anchor"></a><code><span><span class="keyword">type</span> <span>('a, 'b) race</span></span><span> = </span></code><table><tr id="type-race.Left" class="anchored"><td class="def variant constructor"><a href="#type-race.Left" class="anchor"></a><code><span>| </span><span><span class="constructor">Left</span> <span class="keyword">of</span> <span class="type-var">'a</span></span></code></td></tr><tr id="type-race.Right" class="anchored"><td class="def variant constructor"><a href="#type-race.Right" class="anchor"></a><code><span>| </span><span><span class="constructor">Right</span> <span class="keyword">of</span> <span class="type-var">'b</span></span></code></td></tr><tr id="type-race.Both" class="anchored"><td class="def variant constructor"><a href="#type-race.Both" class="anchor"></a><code><span>| </span><span><span class="constructor">Both</span> <span class="keyword">of</span> <span class="type-var">'a</span> * <span class="type-var">'b</span></span></code></td></tr></table></div><div class="spec-doc"><p>Type for <a href="#val-race"><code>race</code></a> result values.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-race" class="anchored"><a href="#val-race" class="anchor"></a><code><span><span class="keyword">val</span> race : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'r1</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'r2</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span><span>(<span class="type-var">'r1</span>, <span class="type-var">'r2</span>)</span> <a href="#type-race">race</a></span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>race left right</code> runs both <code>left</code> and <code>right</code> sinks at the same time producing the result for the one that fills first.</p><p>If the sink is terminated prematurely, before either <code>left</code> or <code>right</code> are filled, <a href="#type-race.Both"><code>Both</code></a> of their values are produced.</p><p>Examples</p><pre><code>let sink = Sink.(race (find ~where:(fun x -&gt; x &gt; 10)) (nth 8)) in
let result = Stream.of_list [1; 9; 0; 8; 30; 4] |&gt; Stream.into sink in
assert (result = Sink.Left (Some 30))</code></pre></div></div><div class="odoc-spec"><div class="spec value" id="val-(&lt;|&gt;)" class="anchored"><a href="#val-(&lt;|&gt;)" class="anchor"></a><code><span><span class="keyword">val</span> (&lt;|&gt;) : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'r1</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'r2</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span><span>(<span class="type-var">'r1</span>, <span class="type-var">'r2</span>)</span> <a href="#type-race">race</a></span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>left &lt;|&gt; right</code> is the operator version of <code>race left right</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-seq" class="anchored"><a href="#val-seq" class="anchor"></a><code><span><span class="keyword">val</span> seq : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'r1</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'r2</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r1</span> * <span class="type-var">'r2</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>seq left right</code> runs <code>left</code> and then <code>right</code> sequentially producing both of their results.</p><p>If the resulting sink is stopped before <code>right</code> was started, it will be forced to initialize and terminate.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-seq_left" class="anchored"><a href="#val-seq_left" class="anchor"></a><code><span><span class="keyword">val</span> seq_left : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'r</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">_</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>seq_left left right</code> is similar to <code>seq</code>, but only produces the result of the <code>left</code> sink.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-seq_right" class="anchored"><a href="#val-seq_right" class="anchor"></a><code><span><span class="keyword">val</span> seq_right : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">_</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'r</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>seq_right left right</code> is similar to <code>seq</code>, but only produces the result of the <code>right</code> sink.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-(&lt;+&gt;)" class="anchored"><a href="#val-(&lt;+&gt;)" class="anchor"></a><code><span><span class="keyword">val</span> (&lt;+&gt;) : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'r1</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'r2</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r1</span> * <span class="type-var">'r2</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>left &lt;+&gt; right</code> is an operator version of <code>seq left right</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-(&lt;+)" class="anchored"><a href="#val-(&lt;+)" class="anchor"></a><code><span><span class="keyword">val</span> (&lt;+) : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'r</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">_</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>left &lt;+ right</code> is an operator version of <code>seq_left left right</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-(+&gt;)" class="anchored"><a href="#val-(+&gt;)" class="anchor"></a><code><span><span class="keyword">val</span> (+&gt;) : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">_</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'r</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>left +&gt; right</code> is an operator version of <code>seq_right left right</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-flat_map" class="anchored"><a href="#val-flat_map" class="anchor"></a><code><span><span class="keyword">val</span> flat_map : <span><span>(<span><span class="type-var">'r1</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r2</span>)</span> <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'r1</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r2</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>flat_map f sink</code> is a sink produced by applying the result of <code>sink</code> to <code>f</code>. This allows to sequence multiple sinks by inspecting the result value produced by the previous sinks.</p><p><code>flat_map</code> is defined as the <code>let*</code> operator in <a href="Syntax/index.html"><code>Syntax</code></a>.</p><p><b>Note:</b> If <code>sink</code> is terminated exhausting the entire input, the sink produced by <code>f</code> will be initialized and immediately forced to terminate.</p><pre><code># let large_values () = Sink.flat_map
    (function
      | Some x -&gt; Printf.printf &quot;Found value: %d\n&quot; x; Sink.list
      | None -&gt; Printf.printf &quot;No value found\n&quot;; Sink.fill [])
    (Sink.find ~where:(fun x -&gt; x &gt; 100))
val sink1 : unit -&gt; (int, int list) sink = &lt;fun&gt;

# let values = Stream.(90 -&lt; 105) |&gt; Stream.into (sink1 ())
Found value: 101
val values : int list = [102; 103; 104]</code></pre></div></div><div class="odoc-spec"><div class="spec value" id="val-(&gt;&gt;=)" class="anchored"><a href="#val-(&gt;&gt;=)" class="anchor"></a><code><span><span class="keyword">val</span> (&gt;&gt;=) : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'r1</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'r1</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r2</span>)</span> <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r2</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>sink &gt;&gt;= f</code> is an operator version of <code>flat_map f sink</code>.</p></div></div><h2 id="mapping-and-filtering-sinks"><a href="#mapping-and-filtering-sinks" class="anchor"></a>Mapping and filtering sinks</h2><div class="odoc-spec"><div class="spec value" id="val-map" class="anchored"><a href="#val-map" class="anchor"></a><code><span><span class="keyword">val</span> map : <span><span>(<span><span class="type-var">'r1</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'r2</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'r1</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r2</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>map f sink</code> is a sink <code>sink</code> with the result transformed with <code>f</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-(&lt;@&gt;)" class="anchored"><a href="#val-(&lt;@&gt;)" class="anchor"></a><code><span><span class="keyword">val</span> (&lt;@&gt;) : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'c</span>, <span class="type-var">'a</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'c</span>, <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>f &lt;@&gt; sink</code> is the operator version of <code>map f sink</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-premap" class="anchored"><a href="#val-premap" class="anchor"></a><code><span><span class="keyword">val</span> premap : <span><span>(<span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'r</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'b</span>, <span class="type-var">'r</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>premap f sink</code> is a sink that <em>premaps</em> the input values.</p><p>Examples</p><p>If <code>sink</code> consumes integers, but we have an input with strings, we can provide a conversion from strings to integers to <code>premap</code>:</p><pre><code>let sink = Sink.(premap int_of_string sum) in
let result = Stream.of_list [&quot;1&quot;; &quot;2&quot;; &quot;3&quot;] |&gt; Stream.into sink in
assert (result = 6)</code></pre></div></div><div class="odoc-spec"><div class="spec value" id="val-prefilter" class="anchored"><a href="#val-prefilter" class="anchor"></a><code><span><span class="keyword">val</span> prefilter : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'r</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>prefilter predicate sink</code> is a sink that filter the input value for <code>sink</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-prefilter_map" class="anchored"><a href="#val-prefilter_map" class="anchor"></a><code><span><span class="keyword">val</span> prefilter_map : <span><span>(<span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'r</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'b</span>, <span class="type-var">'r</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>prefilter_map f sink</code> applies <code>f</code> to every input value <code>x</code> of sink, discarding it if <code>f x</code> produces <code>None</code>, and keeping the transformed value otherwise.</p></div></div><h2 id="resource-management"><a href="#resource-management" class="anchor"></a>Resource management</h2><div class="odoc-spec"><div class="spec value" id="val-stop" class="anchored"><a href="#val-stop" class="anchor"></a><code><span><span class="keyword">val</span> stop : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'r</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'r</span></span></code></div><div class="spec-doc"><p>Stop the sink and produce the currently accumulated result. Any internal state will be terminated. Terminating an uninitialized sink will initialize it.</p></div></div><h2 id="syntax-definitions"><a href="#syntax-definitions" class="anchor"></a>Syntax definitions</h2><p>In addition to using the sinks and operations defined above, it is possible to create sinks with a convenient <code>(let)</code> notation.</p><p>A common example of a composed sink is the sink that computes the arithmetic mean:</p><pre><code>let mean =
  let open Sink.Syntax in
  let+ total = Sink.sum
  and+ count = Sink.len in
  total / count</code></pre><p>The resulting sink has type <code>(int, int) sink</code> and will only consume the input once!</p><div class="odoc-spec"><div class="spec module" id="module-Syntax" class="anchored"><a href="#module-Syntax" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Syntax/index.html">Syntax</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Module with syntax definitions for sinks.</p></div></div><h2 id="interface-implementations"><a href="#interface-implementations" class="anchor"></a>Interface implementations</h2><div class="odoc-spec"><div class="spec module" id="module-Functor" class="anchored"><a href="#module-Functor" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Functor/index.html">Functor</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Module that implements the &quot;Functor&quot; interface.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Applicative" class="anchored"><a href="#module-Applicative" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Applicative/index.html">Applicative</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Module that implements the &quot;Applicative&quot; interface.</p></div></div></div></body></html>