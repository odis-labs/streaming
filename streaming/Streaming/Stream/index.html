<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Stream (streaming.Streaming.Stream)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">streaming</a> &#x00BB; <a href="../index.html">Streaming</a> &#x00BB; Stream</nav><h1>Module <code>Streaming.Stream</code></h1><p>Module with defintions for streams.</p><p>Stream is a purely functional abstraction for incremental, push-based, sequential processing of elements. Streams can be easily and efficiently transformed and concatenated.</p><p>Stream operations do not leak resources. This is guaranteed in the presence of early termination (when not all stream elements are consumed) and in case of exceptions in the streaming pipeline.</p><p>Streams are built to be compatible with <a href="../Source/index.html"><span>sources</span></a>, <a href="../Sink/index.html"><span>sinks</span></a> and <a href="../Flow/index.html"><span>flows</span></a>. To create a stream that produces all elements from a source use <a href="index.html#val-from"><code>Stream.from</code></a>, to consume a stream with a sink use <a href="index.html#val-into"><code>Stream.into</code></a> and to transform stream elements with a flow use <a href="index.html#val-via"><code>Stream.via</code></a>. For more sophisticated pipelines that might have source leftovers, <a href="index.html#val-run"><code>run</code></a> can be used.</p><p>A simple echo program that loops over standard input and prints every line to standard output until Ctrl-D is hit:</p><pre><code class="ml"># Stream.stdin |&gt; Stream.stdout;;
hello&lt;Enter&gt;
hello
world&lt;Enter&gt;
world
&lt;Ctrl+d&gt;
- : unit = ()</code></pre><nav class="toc"><ul><li><a href="#creating-a-stream">Creating a stream</a></li><li><a href="#stream-converters">Stream converters</a></li><li><a href="#transforming-a-stream">Transforming a stream</a></li><li><a href="#combining-streams">Combining streams</a></li><li><a href="#groupping-and-splitting">Groupping and splitting</a></li><li><a href="#consumers">Consumers</a></li><li><a href="#io-streams">IO Streams</a></li><li><a href="#adaptors">Adaptors</a></li><li><a href="#syntax-defintions">Syntax defintions</a></li></ul></nav></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> <span>'a t</span></code><code> = <span><span class="type-var">'a</span> <a href="../index.html#type-stream">stream</a></span></code></dt><dd><p>Type for streams with elements of type <code>'a</code>.</p></dd></dl><section><header><h2 id="creating-a-stream"><a href="#creating-a-stream" class="anchor"></a>Creating a stream</h2></header><dl><dt class="spec value" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span class="keyword">val</span> empty : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p>Empty stream with no elements.</p></dd></dl><dl><dt class="spec value" id="val-single"><a href="#val-single" class="anchor"></a><code><span class="keyword">val</span> single : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>single a</code> is a stream with a single element <code>a</code>.</p></dd></dl><dl><dt class="spec value" id="val-double"><a href="#val-double" class="anchor"></a><code><span class="keyword">val</span> double : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>double a b</code> is a stream with two elements: <code>a</code> and <code>b</code>.</p></dd></dl><dl><dt class="spec value" id="val-triple"><a href="#val-triple" class="anchor"></a><code><span class="keyword">val</span> triple : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>triple a b c</code> is a stream with elements: <code>a</code>, <code>b</code> and <code>c</code>.</p></dd></dl><dl><dt class="spec value" id="val-count"><a href="#val-count" class="anchor"></a><code><span class="keyword">val</span> count : int <span>&#45;&gt;</span> <span>int <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>count n</code> is an infinite stream with integers starting from <code>n</code>.</p></dd></dl><dl><dt class="spec value" id="val-range"><a href="#val-range" class="anchor"></a><code><span class="keyword">val</span> range : <span>?&#8288;by:int</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span>int <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>range ~by:step n m</code> is a sequence of integers starting from <code>n</code> to <code>m</code> (excluding <code>m</code>) incremented by <code>step</code>. The range is open on the right side.</p></dd></dl><dl><dt class="spec value" id="val-iota"><a href="#val-iota" class="anchor"></a><code><span class="keyword">val</span> iota : int <span>&#45;&gt;</span> <span>int <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>iota n</code> is <code>range ~by:1 0 n</code>, that is a range from <code>0</code> to <code>n</code> incremented by <code>1</code>.</p></dd></dl><dl><dt class="spec value" id="val-(-&lt;)"><a href="#val-(-&lt;)" class="anchor"></a><code><span class="keyword">val</span> (-&lt;) : int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span>int <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>n -&lt; m</code> is <code>range n m</code>.</p></dd></dl><dl><dt class="spec value" id="val-(--)"><a href="#val-(--)" class="anchor"></a><code><span class="keyword">val</span> (--) : int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span>int <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>n -- m</code> is <code>range n (m - 1)</code>.</p></dd></dl><dl><dt class="spec value" id="val-generate"><a href="#val-generate" class="anchor"></a><code><span class="keyword">val</span> generate : <span>len:int</span> <span>&#45;&gt;</span> <span>(int <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>generate ~len f</code> generates a stream of length <code>n</code> mapping each index to an element with <code>f</code>.</p></dd></dl><dl><dt class="spec value" id="val-repeat"><a href="#val-repeat" class="anchor"></a><code><span class="keyword">val</span> repeat : <span>?&#8288;times:int</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>repeat ~times:n x</code> produces a stream by repeating <code>x</code> <code>n</code> times. If <code>times</code> is omitted, <code>x</code> is repeated <em>ad infinitum</em>.</p></dd></dl><dl><dt class="spec value" id="val-repeatedly"><a href="#val-repeatedly" class="anchor"></a><code><span class="keyword">val</span> repeatedly : <span>?&#8288;times:int</span> <span>&#45;&gt;</span> <span>(unit <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>repeatedly ~times:n f</code> produces a stream by repeatedly calling <code>f ()</code> <code>n</code> times. If <code>times</code> is omitted, <code>f</code> is called <em>ad infinitum</em>.</p></dd></dl><dl><dt class="spec value" id="val-iterate"><a href="#val-iterate" class="anchor"></a><code><span class="keyword">val</span> iterate : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>iterate x f</code> is an infinite source where the first item is calculated by applying <code>f</code> to <code>x</code>, the second item by applying the function on the previous result and so on.</p></dd></dl><dl><dt class="spec value" id="val-unfold"><a href="#val-unfold" class="anchor"></a><code><span class="keyword">val</span> unfold : <span class="type-var">'s</span> <span>&#45;&gt;</span> <span>(<span class="type-var">'s</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'s</span>)</span> option</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>unfold seed next</code> is a stream created from a <code>seed</code> state and a function that produces elements and an updated state. The stream will terminate when <code>next</code> produces <code>None</code>.</p></dd></dl><dl><dt class="spec value" id="val-yield"><a href="#val-yield" class="anchor"></a><code><span class="keyword">val</span> yield : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>yield x</code> is a stream with a single element <code>x</code>. Alias for <code>single</code>.</p></dd></dl></section><section><header><h2 id="stream-converters"><a href="#stream-converters" class="anchor"></a>Stream converters</h2></header><dl><dt class="spec value" id="val-of_list"><a href="#val-of_list" class="anchor"></a><code><span class="keyword">val</span> of_list : <span><span class="type-var">'a</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>of_list items</code> is a stream with all elements in the list <code>items</code>.</p></dd></dl><dl><dt class="spec value" id="val-to_list"><a href="#val-to_list" class="anchor"></a><code><span class="keyword">val</span> to_list : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> list</span></code></dt><dd><p><code>to_list stream</code> converts <code>stream</code> into a list.</p></dd></dl><dl><dt class="spec value" id="val-of_array"><a href="#val-of_array" class="anchor"></a><code><span class="keyword">val</span> of_array : <span><span class="type-var">'a</span> array</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>of_array items</code> is a stream with all elements in the array <code>items</code>.</p></dd></dl><dl><dt class="spec value" id="val-to_array"><a href="#val-to_array" class="anchor"></a><code><span class="keyword">val</span> to_array : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> array</span></code></dt><dd><p><code>to_array stream</code> converts <code>stream</code> into an array.</p></dd></dl><dl><dt class="spec value" id="val-of_string"><a href="#val-of_string" class="anchor"></a><code><span class="keyword">val</span> of_string : string <span>&#45;&gt;</span> <span>char <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>of_string string</code> is a stream with all characters in <code>string</code>.</p></dd></dl><dl><dt class="spec value" id="val-to_string"><a href="#val-to_string" class="anchor"></a><code><span class="keyword">val</span> to_string : <span>char <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> string</code></dt><dd><p><code>to_string stream</code> converts <code>stream</code> of characters into a string.</p></dd></dl><dl><dt class="spec value" id="val-of_iter"><a href="#val-of_iter" class="anchor"></a><code><span class="keyword">val</span> of_iter : <span>(<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>of_iter iter</code> is a stream created with elements generated by <code>iter</code>.</p><p><code>iter</code> is an iterator that takes a consumer funcion that will recieve the produced values. An example of such a function is <code>List.iter</code>.</p><h5 id="examples"><a href="#examples" class="anchor"></a>Examples</h5><pre><code class="ml"># let iter k = List.iter k [1; 2; 3] in
  Stream.fold (+) 0 (Stream.of_iter iter)
- : int = 6</code></pre></dd></dl></section><section><header><h2 id="transforming-a-stream"><a href="#transforming-a-stream" class="anchor"></a>Transforming a stream</h2></header><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p>A stream with all elements transformed with a mapping function.</p></dd></dl><dl><dt class="spec value" id="val-filter"><a href="#val-filter" class="anchor"></a><code><span class="keyword">val</span> filter : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p>A stream that includes only the elements that satisfy a predicate.</p></dd></dl><dl><dt class="spec value" id="val-filter_map"><a href="#val-filter_map" class="anchor"></a><code><span class="keyword">val</span> filter_map : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> option</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>filter_map f source</code> applies <code>f</code> to every element <code>x</code> of source, discarding it if <code>f x</code> produces <code>None</code>, and keeping the transformed value otherwise.</p></dd></dl><dl><dt class="spec value" id="val-take"><a href="#val-take" class="anchor"></a><code><span class="keyword">val</span> take : int <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p>Take first <code>n</code> elements from the stream and discard the rest.</p></dd></dl><dl><dt class="spec value" id="val-take_while"><a href="#val-take_while" class="anchor"></a><code><span class="keyword">val</span> take_while : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p>Take first elements from the stream that satisfy a predicate and discard the rest.</p></dd></dl><dl><dt class="spec value" id="val-drop_while"><a href="#val-drop_while" class="anchor"></a><code><span class="keyword">val</span> drop_while : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p>Drpo first elements from the stream that satisfy a predicate and keep the rest.</p></dd></dl><dl><dt class="spec value" id="val-drop"><a href="#val-drop" class="anchor"></a><code><span class="keyword">val</span> drop : int <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p>Drop first <code>n</code> elements from the stream and keep the rest.</p></dd></dl><dl><dt class="spec value" id="val-rest"><a href="#val-rest" class="anchor"></a><code><span class="keyword">val</span> rest : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p>Drops the first element of the stream.</p></dd></dl><dl><dt class="spec value" id="val-indexed"><a href="#val-indexed" class="anchor"></a><code><span class="keyword">val</span> indexed : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(int * <span class="type-var">'a</span>)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p>Adds an index to each element in the stream.</p></dd></dl></section><section><header><h2 id="combining-streams"><a href="#combining-streams" class="anchor"></a>Combining streams</h2></header><dl><dt class="spec value" id="val-concat"><a href="#val-concat" class="anchor"></a><code><span class="keyword">val</span> concat : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>concat stream1 stream2</code> is a stream that exhausts all elements from <code>stream1</code> and then all elements from <code>stream2</code>.</p><h5 id="examples"><a href="#examples" class="anchor"></a>Examples</h5><pre><code class="ml"># let stream1 = Stream.of_list ['a'; 'b'; 'c'] in
  let stream2 = Stream.of_list ['d'; 'e'; 'f'] in
  Stream.to_list (Stream.concat stream1 stream2)
- : char list = ['a'; 'b'; 'c'; 'd'; 'e'; 'f']</code></pre></dd></dl><dl><dt class="spec value" id="val-(++)"><a href="#val-(++)" class="anchor"></a><code><span class="keyword">val</span> (++) : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>stream1 ++ stream2</code> is the infix operator version of <code>concat stream1 stream2</code>.</p></dd></dl><dl><dt class="spec value" id="val-append"><a href="#val-append" class="anchor"></a><code><span class="keyword">val</span> append : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>append x stream</code> adds the element <code>x</code> to the end of <code>stream</code>.</p></dd></dl><dl><dt class="spec value" id="val-prepend"><a href="#val-prepend" class="anchor"></a><code><span class="keyword">val</span> prepend : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>prepend x stream</code> adds the element <code>x</code> to the beginning of <code>stream</code>.</p></dd></dl><dl><dt class="spec value" id="val-flatten"><a href="#val-flatten" class="anchor"></a><code><span class="keyword">val</span> flatten : <span><span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p>Concatenates a stream of streams.</p></dd></dl><dl><dt class="spec value" id="val-flat_map"><a href="#val-flat_map" class="anchor"></a><code><span class="keyword">val</span> flat_map : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>flat_map f stream</code> is a stream concatenated from sub-streams produced by applying <code>f</code> to all elements of <code>stream</code>.</p><pre><code class="ml">let duplicated =
  [1; 2; 3]
  |&gt; String.of_list
  |&gt; String.flat_map (fun x -&gt; Stream.of_list [x; x])
  |&gt; Stream.to_list in
assert (duplicated = [1; 1; 2; 2; 3; 3])</code></pre></dd></dl><dl><dt class="spec value" id="val-cycle"><a href="#val-cycle" class="anchor"></a><code><span class="keyword">val</span> cycle : <span>?&#8288;times:int</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>cycle ~times:n stream</code> produces a stream by repeating all elements from <code>stream</code> <code>n</code> times. If <code>times</code> is omitted, <code>x</code> is repeated <em>ad infinitum</em>.</p></dd></dl><dl><dt class="spec value" id="val-interpose"><a href="#val-interpose" class="anchor"></a><code><span class="keyword">val</span> interpose : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p>Inserts a separator element between each stream element.</p></dd></dl></section><section><header><h2 id="groupping-and-splitting"><a href="#groupping-and-splitting" class="anchor"></a>Groupping and splitting</h2></header><dl><dt class="spec value" id="val-partition"><a href="#val-partition" class="anchor"></a><code><span class="keyword">val</span> partition : int <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>partition n</code> partitions the stream into sub-streams of size <code>n</code>.</p></dd></dl><dl><dt class="spec value" id="val-split"><a href="#val-split" class="anchor"></a><code><span class="keyword">val</span> split : <span>by:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>split ~by:predicate stream</code> splits <code>stream</code> when <code>predicate x</code> is <code>true</code> for some stream item <code>x</code>.</p></dd></dl><dl><dt class="spec value" id="val-through"><a href="#val-through" class="anchor"></a><code><span class="keyword">val</span> through : <span><span>(<span class="type-var">'a</span>,Â <span class="type-var">'r</span>)</span> <a href="../index.html#type-sink">sink</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'r</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>through sink stream</code> repeatedly processes <code>stream</code> elements with <code>sink</code> streaming computed results.</p><p><b>Note:</b> The provided sink might consume the whole input if it never fills, or if the stream terminates before filling the sink.</p><pre><code class="ml">let large_numbers =
  [1; 100; 2; 200; 3; 300]
  |&gt; Stream.of_list
  |&gt; Stream.through (Sink.find ~where:(fun x -&gt; x &gt; 10)) in
assert (Stream.to_list large_numbers = [Some 100; Some 200; Some 300])</code></pre></dd></dl></section><section><header><h2 id="consumers"><a href="#consumers" class="anchor"></a>Consumers</h2><p>Operations that traverse the the stream computing a single result value.</p><p>If the stream is infinite and the consumer accumulates the elements, the processing will not terminate, potentially resulting in a memory leak.</p></header><dl><dt class="spec value" id="val-len"><a href="#val-len" class="anchor"></a><code><span class="keyword">val</span> len : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> int</code></dt><dd><p><code>len stream</code> counts the number of elements in <code>stream</code>.</p><p>Will exhaust the stream during processing.</p><h5 id="examples"><a href="#examples" class="anchor"></a>Examples</h5><pre><code class="ml"># Stream.len (Stream.of_list ['a'; 'b'; 'c']);
- : int = 3</code></pre></dd></dl><dl><dt class="spec value" id="val-each"><a href="#val-each" class="anchor"></a><code><span class="keyword">val</span> each : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>each f stream</code> applies an effectful function <code>f</code> to all elements of <code>stream</code>.</p></dd></dl><dl><dt class="spec value" id="val-fold"><a href="#val-fold" class="anchor"></a><code><span class="keyword">val</span> fold : <span>(<span class="type-var">'r</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'r</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'r</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span class="type-var">'r</span></code></dt><dd><p><code>fold step init stream</code> reduces the values of <code>stream</code> with the <code>step</code> function, starting with <code>init</code>.</p><p>If the <code>step</code> function raises an exception, the stream will be properly terminated.</p></dd></dl><dl><dt class="spec value" id="val-is_empty"><a href="#val-is_empty" class="anchor"></a><code><span class="keyword">val</span> is_empty : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_empty stream</code> is <code>true</code> if the stream has no elements and <code>false</code> otherwise. This operations consumes the first elements of the stream.</p></dd></dl><dl><dt class="spec value" id="val-first"><a href="#val-first" class="anchor"></a><code><span class="keyword">val</span> first : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> option</span></code></dt><dd><p>Return the first element in the stream.</p></dd></dl><dl><dt class="spec value" id="val-last"><a href="#val-last" class="anchor"></a><code><span class="keyword">val</span> last : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> option</span></code></dt><dd><p>Return the last element in the stream, in linear time.</p></dd></dl><dl><dt class="spec value" id="val-drain"><a href="#val-drain" class="anchor"></a><code><span class="keyword">val</span> drain : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> unit</code></dt></dl></section><section><header><h2 id="io-streams"><a href="#io-streams" class="anchor"></a>IO Streams</h2></header><dl><dt class="spec value" id="val-of_file"><a href="#val-of_file" class="anchor"></a><code><span class="keyword">val</span> of_file : string <span>&#45;&gt;</span> <span>string <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>of_file path</code> is a stream of lines read from the file located at <code>path</code>.</p><p>The file is opened lazily only when the stream is consumed and will be closed even if the stream processing terminates with an exception.</p></dd></dl><dl><dt class="spec value" id="val-to_file"><a href="#val-to_file" class="anchor"></a><code><span class="keyword">val</span> to_file : string <span>&#45;&gt;</span> <span>string <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>to_file path stream</code> writes lines from <code>stream</code> into the file located at <code>path</code>.</p></dd></dl><dl><dt class="spec value" id="val-stdin"><a href="#val-stdin" class="anchor"></a><code><span class="keyword">val</span> stdin : <span>string <a href="index.html#type-t">t</a></span></code></dt><dd><p>The stream that reads lines from the standard input channel.</p></dd></dl><dl><dt class="spec value" id="val-stdout"><a href="#val-stdout" class="anchor"></a><code><span class="keyword">val</span> stdout : <span>string <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p>The stream that writes lines to standard output channel.</p></dd></dl><dl><dt class="spec value" id="val-stderr"><a href="#val-stderr" class="anchor"></a><code><span class="keyword">val</span> stderr : <span>string <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p>The stream that writes lines to standard error channel.</p></dd></dl></section><section><header><h2 id="adaptors"><a href="#adaptors" class="anchor"></a>Adaptors</h2><p>Integration adaptors for <a href="#sources">sources</a>, <a href="#sinks">sinks</a> and <a href="#flows">flows</a>.</p></header><dl><dt class="spec value" id="val-from"><a href="#val-from" class="anchor"></a><code><span class="keyword">val</span> from : <span><span class="type-var">'a</span> <a href="../index.html#type-source">source</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>from source</code> is a stream created from a source.</p><h5 id="examples"><a href="#examples" class="anchor"></a>Examples</h5><pre><code class="ml"># Stream.len (Stream.from (Source.list [0; 1; 2]))
- : int = 3</code></pre></dd></dl><dl><dt class="spec value" id="val-into"><a href="#val-into" class="anchor"></a><code><span class="keyword">val</span> into : <span><span>(<span class="type-var">'a</span>,Â <span class="type-var">'b</span>)</span> <a href="../index.html#type-sink">sink</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dd><p><code>into sink stream</code> is the result value produced by streaming all elements of <code>stream</code> into <code>sink</code>.</p><h5 id="examples"><a href="#examples" class="anchor"></a>Examples</h5><pre><code class="ml"># Stream.into Sink.sum (Stream.of_list [0; 1; 2])
- : int = 3</code></pre></dd></dl><aside><p><code>fill sink stream</code> is similar to <code>into</code> but, in addition to the result value produced by <code>sink</code>, will optionally return a leftover stream with elements that were not consumed by <code>sink</code>.</p></aside><dl><dt class="spec value" id="val-via"><a href="#val-via" class="anchor"></a><code><span class="keyword">val</span> via : <span><span>(<span class="type-var">'a</span>,Â <span class="type-var">'b</span>)</span> <a href="../index.html#type-flow">flow</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../index.html#type-stream">stream</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="../index.html#type-stream">stream</a></span></code></dt><dd><p><code>via flow stream</code> is stream produced by transforming all elements of <code>stream</code> via <code>flow</code>.</p><h5 id="examples"><a href="#examples" class="anchor"></a>Examples</h5><pre><code class="ml">Stream.count 100
|&gt; Stream.via (Flow.filter (fun x -&gt; x mod 2 = 0))
|&gt; Stream.via (Flow.take 50)
|&gt; Stream.into Sink.sum</code></pre></dd></dl><dl><dt class="spec value" id="val-run"><a href="#val-run" class="anchor"></a><code><span class="keyword">val</span> run : <span>from:<span><span class="type-var">'a</span> <a href="../index.html#type-source">source</a></span></span> <span>&#45;&gt;</span> <span>via:<span><span>(<span class="type-var">'a</span>,Â <span class="type-var">'b</span>)</span> <a href="../index.html#type-flow">flow</a></span></span> <span>&#45;&gt;</span> <span>into:<span><span>(<span class="type-var">'b</span>,Â <span class="type-var">'r</span>)</span> <a href="../index.html#type-sink">sink</a></span></span> <span>&#45;&gt;</span> <span class="type-var">'r</span> * <span><span><span class="type-var">'a</span> <a href="../index.html#type-source">source</a></span> option</span></code></dt><dd><p>Fuses sources, sinks and flows and produces a result and a leftover.</p><pre><code class="ml">let (r, leftover) = Stream.run ~from:source via:flow ~into:sink</code></pre><p>Streams elements from <code>source</code> into <code>sink</code> via a stream transformer <code>flow</code>. In addition to the result value <code>r</code> produced by <code>sink</code>, a <code>leftover</code> source is returned, if <code>source</code> was not exhausted.</p><p><b>Warning:</b> If a leftover source is produced, it is required to either consume it or manually <a href="../Source/index.html#val-dispose"><span>dispose</span></a> its resources. Not doing so might lead to resource leaks.</p><h5 id="examples"><a href="#examples" class="anchor"></a>Examples</h5><pre><code class="ml"># let (x, leftover) =
    let source = Source.list [&quot;1&quot;; &quot;2&quot;; &quot;3&quot;] in
    let flow = Flow.map int_of_string in
    Stream.run ~from:source ~via:flow ~into:Sink.first
val x : int option = Some 1
val leftover : string source option = Some &lt;abstr&gt;
# match leftover with
  | Some source -&gt; Source.dispose source
  | None -&gt; print_endline &quot;No leftover&quot;
- : unit = ()</code></pre></dd></dl></section><section><header><h2 id="syntax-defintions"><a href="#syntax-defintions" class="anchor"></a>Syntax defintions</h2><p>Streams can be constructed with the let-binding syntax which is similar to <a href="https://en.wikipedia.org/wiki/List_comprehension">list comprehensions</a>. The following example demonstrates this feature:</p><pre><code class="ml">open Stream.Syntax

let items =
  let* n = Stream.range 1 3 in
  let* c = Stream.of_list ['x'; 'y'] in
  yield (n, c) in
assert (Stream.to_list items = [(1, 'x'); (1, 'y'); (2, 'x'); (2, 'y')])</code></pre></header><dl><dt class="spec module" id="module-Syntax"><a href="#module-Syntax" class="anchor"></a><code><span class="keyword">module</span> <a href="Syntax/index.html">Syntax</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Module with syntax definitions for streams.</p></dd></dl></section></div></body></html>