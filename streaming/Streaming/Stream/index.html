<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Stream (streaming.Streaming.Stream)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../../index.html">streaming</a> &#x00BB; <a href="../index.html">Streaming</a> &#x00BB; Stream</nav><header class="odoc-preamble"><h1>Module <code><span>Streaming.Stream</span></code></h1><p>Module with defintions for streams.</p><p>Stream is a purely functional abstraction for incremental, push-based, sequential processing of elements. Streams can be easily and efficiently transformed and concatenated.</p><p>Stream operations do not leak resources. This is guaranteed in the presence of early termination (when not all stream elements are consumed) and in case of exceptions in the streaming pipeline.</p><p>Streams are built to be compatible with <a href="../Source/index.html">sources</a>, <a href="../Sink/index.html">sinks</a> and <a href="../Flow/index.html">flows</a>. To create a stream that produces all elements from a source use <a href="#val-from"><code>Stream.from</code></a>, to consume a stream with a sink use <a href="#val-into"><code>Stream.into</code></a> and to transform stream elements with a flow use <a href="#val-via"><code>Stream.via</code></a>. For more sophisticated pipelines that might have source leftovers, <code>run</code> can be used.</p><p>A simple echo program that loops over standard input and prints every line to standard output until Ctrl-D is hit:</p><pre><code># Stream.stdin |&gt; Stream.stdout;;
hello&lt;Enter&gt;
hello
world&lt;Enter&gt;
world
&lt;Ctrl+d&gt;
- : unit = ()</code></pre></header><nav class="odoc-toc"><ul><li><a href="#creating-a-stream">Creating a stream</a></li><li><a href="#stream-converters">Stream converters</a></li><li><a href="#transforming-a-stream">Transforming a stream</a></li><li><a href="#combining-streams">Combining streams</a></li><li><a href="#groupping-and-splitting">Groupping and splitting</a></li><li><a href="#consumers">Consumers</a></li><li><a href="#io-streams">IO Streams</a></li><li><a href="#adaptors">Adaptors</a></li><li><a href="#syntax-defintions">Syntax defintions</a></li></ul></nav><div class="odoc-content"><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a t</span></span><span> = <span><span class="type-var">'a</span> <a href="../index.html#type-stream">stream</a></span></span></code></div><div class="spec-doc"><p>Type for streams with elements of type <code>'a</code>.</p></div></div><h2 id="creating-a-stream"><a href="#creating-a-stream" class="anchor"></a>Creating a stream</h2><div class="odoc-spec"><div class="spec value" id="val-empty" class="anchored"><a href="#val-empty" class="anchor"></a><code><span><span class="keyword">val</span> empty : <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Empty stream with no elements.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-single" class="anchored"><a href="#val-single" class="anchor"></a><code><span><span class="keyword">val</span> single : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>single a</code> is a stream with a single element <code>a</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-double" class="anchored"><a href="#val-double" class="anchor"></a><code><span><span class="keyword">val</span> double : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>double a b</code> is a stream with two elements: <code>a</code> and <code>b</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-triple" class="anchored"><a href="#val-triple" class="anchor"></a><code><span><span class="keyword">val</span> triple : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>triple a b c</code> is a stream with elements: <code>a</code>, <code>b</code> and <code>c</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-count" class="anchored"><a href="#val-count" class="anchor"></a><code><span><span class="keyword">val</span> count : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>count n</code> is an infinite stream with integers starting from <code>n</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-range" class="anchored"><a href="#val-range" class="anchor"></a><code><span><span class="keyword">val</span> range : <span>?by:int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>range ~by:step n m</code> is a sequence of integers starting from <code>n</code> to <code>m</code> (excluding <code>m</code>) incremented by <code>step</code>. The range is open on the right side.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-iota" class="anchored"><a href="#val-iota" class="anchor"></a><code><span><span class="keyword">val</span> iota : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>iota n</code> is <code>range ~by:1 0 n</code>, that is a range from <code>0</code> to <code>n</code> incremented by <code>1</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-(-&lt;)" class="anchored"><a href="#val-(-&lt;)" class="anchor"></a><code><span><span class="keyword">val</span> (-&lt;) : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>n -&lt; m</code> is <code>range n m</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-(--)" class="anchored"><a href="#val-(--)" class="anchor"></a><code><span><span class="keyword">val</span> (--) : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>n -- m</code> is <code>range n (m - 1)</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-generate" class="anchored"><a href="#val-generate" class="anchor"></a><code><span><span class="keyword">val</span> generate : <span>len:int <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>generate ~len f</code> generates a stream of length <code>n</code> mapping each index to an element with <code>f</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-repeat" class="anchored"><a href="#val-repeat" class="anchor"></a><code><span><span class="keyword">val</span> repeat : <span>?times:int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>repeat ~times:n x</code> produces a stream by repeating <code>x</code> <code>n</code> times. If <code>times</code> is omitted, <code>x</code> is repeated <em>ad infinitum</em>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-repeatedly" class="anchored"><a href="#val-repeatedly" class="anchor"></a><code><span><span class="keyword">val</span> repeatedly : <span>?times:int <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>repeatedly ~times:n f</code> produces a stream by repeatedly calling <code>f ()</code> <code>n</code> times. If <code>times</code> is omitted, <code>f</code> is called <em>ad infinitum</em>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-iterate" class="anchored"><a href="#val-iterate" class="anchor"></a><code><span><span class="keyword">val</span> iterate : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>iterate x f</code> is an infinite source where the first item is calculated by applying <code>f</code> to <code>x</code>, the second item by applying the function on the previous result and so on.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-unfold" class="anchored"><a href="#val-unfold" class="anchor"></a><code><span><span class="keyword">val</span> unfold : <span><span class="type-var">'s</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'s</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'s</span>)</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>unfold seed next</code> is a stream created from a <code>seed</code> state and a function that produces elements and an updated state. The stream will terminate when <code>next</code> produces <code>None</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-yield" class="anchored"><a href="#val-yield" class="anchor"></a><code><span><span class="keyword">val</span> yield : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>yield x</code> is a stream with a single element <code>x</code>. Alias for <code>single</code>.</p></div></div><h2 id="stream-converters"><a href="#stream-converters" class="anchor"></a>Stream converters</h2><div class="odoc-spec"><div class="spec value" id="val-of_list" class="anchored"><a href="#val-of_list" class="anchor"></a><code><span><span class="keyword">val</span> of_list : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>of_list items</code> is a stream with all elements in the list <code>items</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-to_list" class="anchored"><a href="#val-to_list" class="anchor"></a><code><span><span class="keyword">val</span> to_list : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>to_list stream</code> converts <code>stream</code> into a list.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_array" class="anchored"><a href="#val-of_array" class="anchor"></a><code><span><span class="keyword">val</span> of_array : <span><span><span class="type-var">'a</span> array</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>of_array items</code> is a stream with all elements in the array <code>items</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-to_array" class="anchored"><a href="#val-to_array" class="anchor"></a><code><span><span class="keyword">val</span> to_array : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> array</span></span></code></div><div class="spec-doc"><p><code>to_array stream</code> converts <code>stream</code> into an array.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_string" class="anchored"><a href="#val-of_string" class="anchor"></a><code><span><span class="keyword">val</span> of_string : <span>string <span class="arrow">&#45;&gt;</span></span> <span>char <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>of_string string</code> is a stream with all characters in <code>string</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-to_string" class="anchored"><a href="#val-to_string" class="anchor"></a><code><span><span class="keyword">val</span> to_string : <span><span>char <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>to_string stream</code> converts <code>stream</code> of characters into a string.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_iter" class="anchored"><a href="#val-of_iter" class="anchor"></a><code><span><span class="keyword">val</span> of_iter : <span><span>(<span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>of_iter iter</code> is a stream created with elements generated by <code>iter</code>.</p><p><code>iter</code> is an iterator that takes a consumer funcion that will recieve the produced values. An example of such a function is <code>List.iter</code>.</p><p>Examples</p><pre><code># let iter k = List.iter k [1; 2; 3] in
  Stream.fold (+) 0 (Stream.of_iter iter)
- : int = 6</code></pre></div></div><h2 id="transforming-a-stream"><a href="#transforming-a-stream" class="anchor"></a>Transforming a stream</h2><div class="odoc-spec"><div class="spec value" id="val-map" class="anchored"><a href="#val-map" class="anchor"></a><code><span><span class="keyword">val</span> map : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>A stream with all elements transformed with a mapping function.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-tap" class="anchored"><a href="#val-tap" class="anchor"></a><code><span><span class="keyword">val</span> tap : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Pass each element through an effectful function.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-filter" class="anchored"><a href="#val-filter" class="anchor"></a><code><span><span class="keyword">val</span> filter : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>A stream that includes only the elements that satisfy a predicate.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-filter_map" class="anchored"><a href="#val-filter_map" class="anchor"></a><code><span><span class="keyword">val</span> filter_map : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>filter_map f source</code> applies <code>f</code> to every element <code>x</code> of source, discarding it if <code>f x</code> produces <code>None</code>, and keeping the transformed value otherwise.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-take" class="anchored"><a href="#val-take" class="anchor"></a><code><span><span class="keyword">val</span> take : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Take first <code>n</code> elements from the stream and discard the rest.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-take_while" class="anchored"><a href="#val-take_while" class="anchor"></a><code><span><span class="keyword">val</span> take_while : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Take first elements from the stream that satisfy a predicate and discard the rest.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-drop_while" class="anchored"><a href="#val-drop_while" class="anchor"></a><code><span><span class="keyword">val</span> drop_while : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Drpo first elements from the stream that satisfy a predicate and keep the rest.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-drop" class="anchored"><a href="#val-drop" class="anchor"></a><code><span><span class="keyword">val</span> drop : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Drop first <code>n</code> elements from the stream and keep the rest.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-rest" class="anchored"><a href="#val-rest" class="anchor"></a><code><span><span class="keyword">val</span> rest : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Drops the first element of the stream.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-indexed" class="anchored"><a href="#val-indexed" class="anchor"></a><code><span><span class="keyword">val</span> indexed : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(int * <span class="type-var">'a</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Adds an index to each element in the stream.</p></div></div><h2 id="combining-streams"><a href="#combining-streams" class="anchor"></a>Combining streams</h2><div class="odoc-spec"><div class="spec value" id="val-concat" class="anchored"><a href="#val-concat" class="anchor"></a><code><span><span class="keyword">val</span> concat : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>concat stream1 stream2</code> is a stream that exhausts all elements from <code>stream1</code> and then all elements from <code>stream2</code>.</p><p>Examples</p><pre><code># let stream1 = Stream.of_list ['a'; 'b'; 'c'] in
  let stream2 = Stream.of_list ['d'; 'e'; 'f'] in
  Stream.to_list (Stream.concat stream1 stream2)
- : char list = ['a'; 'b'; 'c'; 'd'; 'e'; 'f']</code></pre></div></div><div class="odoc-spec"><div class="spec value" id="val-(++)" class="anchored"><a href="#val-(++)" class="anchor"></a><code><span><span class="keyword">val</span> (++) : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>stream1 ++ stream2</code> is the infix operator version of <code>concat stream1 stream2</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-append" class="anchored"><a href="#val-append" class="anchor"></a><code><span><span class="keyword">val</span> append : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>append x stream</code> adds the element <code>x</code> to the end of <code>stream</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-prepend" class="anchored"><a href="#val-prepend" class="anchor"></a><code><span><span class="keyword">val</span> prepend : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>prepend x stream</code> adds the element <code>x</code> to the beginning of <code>stream</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-flatten" class="anchored"><a href="#val-flatten" class="anchor"></a><code><span><span class="keyword">val</span> flatten : <span><span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Concatenates a stream of streams.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-flat_map" class="anchored"><a href="#val-flat_map" class="anchor"></a><code><span><span class="keyword">val</span> flat_map : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>flat_map f stream</code> is a stream concatenated from sub-streams produced by applying <code>f</code> to all elements of <code>stream</code>.</p><pre><code>let duplicated =
  [1; 2; 3]
  |&gt; String.of_list
  |&gt; String.flat_map (fun x -&gt; Stream.of_list [x; x])
  |&gt; Stream.to_list in
assert (duplicated = [1; 1; 2; 2; 3; 3])</code></pre></div></div><div class="odoc-spec"><div class="spec value" id="val-cycle" class="anchored"><a href="#val-cycle" class="anchor"></a><code><span><span class="keyword">val</span> cycle : <span>?times:int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>cycle ~times:n stream</code> produces a stream by repeating all elements from <code>stream</code> <code>n</code> times. If <code>times</code> is omitted, <code>x</code> is repeated <em>ad infinitum</em>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-interpose" class="anchored"><a href="#val-interpose" class="anchor"></a><code><span><span class="keyword">val</span> interpose : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Inserts a separator element between each stream element.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-product" class="anchored"><a href="#val-product" class="anchor"></a><code><span><span class="keyword">val</span> product : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>product outer inner</code> is a cartesian product of streams <code>outer</code> and <code>inner</code>.</p><p>Same as <code>product_with (fun x y -&gt; (x, y))</code>.</p><pre><code>let pairs =
  Stream.product (Stream.range 0 3) (Stream.of_string &quot;ab&quot;)
  |&gt; Stream.to_list in
assert (pairs = [(0, 'a'); (0, 'b'); (1, 'a'); (1, 'b'); (2, 'a'); (2, 'b')])</code></pre></div></div><div class="odoc-spec"><div class="spec value" id="val-product_with" class="anchored"><a href="#val-product_with" class="anchor"></a><code><span><span class="keyword">val</span> product_with : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'c</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>product_with combine outer inner</code> is a cartesian product of streams <code>outer</code> and <code>inner</code> with pairs combined with <code>combine</code>.</p></div></div><h2 id="groupping-and-splitting"><a href="#groupping-and-splitting" class="anchor"></a>Groupping and splitting</h2><div class="odoc-spec"><div class="spec value" id="val-partition" class="anchored"><a href="#val-partition" class="anchor"></a><code><span><span class="keyword">val</span> partition : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>partition n</code> partitions the stream into sub-streams of size <code>n</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-split" class="anchored"><a href="#val-split" class="anchor"></a><code><span><span class="keyword">val</span> split : <span>by:<span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>split ~by:predicate stream</code> splits <code>stream</code> when <code>predicate x</code> is <code>true</code> for some stream item <code>x</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-split_between" class="anchored"><a href="#val-split_between" class="anchor"></a><code><span><span class="keyword">val</span> split_between : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span>into:<span><span>(<span class="type-var">'a</span>, <span class="type-var">'r</span>)</span> <a href="../index.html#type-sink">sink</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'r</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Split stream elements based on a binary predicate.</p><p><code>split_between predicate ~into:sink stream</code> is a stream of values computed from groups of consecutive elements by continuously feeding <code>sink</code>. When the binary <code>predicate</code> is <code>true</code> for a pair of elements, the currently aggregated sink value is yielded and a new group is started.</p><p>If the input stream has less than 2 elements, <code>predicate</code> is never called and the sink is computed with 1 or no elements.</p><pre><code>let sums_of_groups =
  [1; 2; 3; 101; 102; 103; 1001; 1002; 1003]
  |&gt; Stream.of_list
  |&gt; Stream.split_between
      (fun x y -&gt; y - x &gt; 10)
      ~into:Sink.sum in
assert (Stream.to_list sums_of_groups = [6; 306; 3006])</code></pre></div></div><div class="odoc-spec"><div class="spec value" id="val-through" class="anchored"><a href="#val-through" class="anchor"></a><code><span><span class="keyword">val</span> through : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'r</span>)</span> <a href="../index.html#type-sink">sink</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'r</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>through sink stream</code> repeatedly processes <code>stream</code> elements with <code>sink</code> streaming computed results.</p><p><b>Note:</b> The provided sink might consume the whole input if it never fills, or if the stream terminates before filling the sink.</p><pre><code>let large_numbers =
  [1; 100; 2; 200; 3; 300]
  |&gt; Stream.of_list
  |&gt; Stream.through (Sink.find ~where:(fun x -&gt; x &gt; 10)) in
assert (Stream.to_list large_numbers = [Some 100; Some 200; Some 300])</code></pre></div></div><h2 id="consumers"><a href="#consumers" class="anchor"></a>Consumers</h2><p>Operations that traverse the the stream computing a single result value.</p><p>If the stream is infinite and the consumer accumulates the elements, the processing will not terminate, potentially resulting in a memory leak.</p><div class="odoc-spec"><div class="spec value" id="val-len" class="anchored"><a href="#val-len" class="anchor"></a><code><span><span class="keyword">val</span> len : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>len stream</code> counts the number of elements in <code>stream</code>.</p><p>Will exhaust the stream during processing.</p><p>Examples</p><pre><code># Stream.len (Stream.of_list ['a'; 'b'; 'c']);
- : int = 3</code></pre></div></div><div class="odoc-spec"><div class="spec value" id="val-each" class="anchored"><a href="#val-each" class="anchor"></a><code><span><span class="keyword">val</span> each : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>each f stream</code> applies an effectful function <code>f</code> to all elements of <code>stream</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fold" class="anchored"><a href="#val-fold" class="anchor"></a><code><span><span class="keyword">val</span> fold : <span><span>(<span><span class="type-var">'r</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'r</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'r</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'r</span></span></code></div><div class="spec-doc"><p><code>fold step init stream</code> reduces the values of <code>stream</code> with the <code>step</code> function, starting with <code>init</code>.</p><p>If the <code>step</code> function raises an exception, the stream will be properly terminated.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-is_empty" class="anchored"><a href="#val-is_empty" class="anchor"></a><code><span><span class="keyword">val</span> is_empty : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_empty stream</code> is <code>true</code> if the stream has no elements and <code>false</code> otherwise. This operations consumes the first elements of the stream.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-first" class="anchored"><a href="#val-first" class="anchor"></a><code><span><span class="keyword">val</span> first : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span></span></code></div><div class="spec-doc"><p>Return the first element in the stream.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-last" class="anchored"><a href="#val-last" class="anchor"></a><code><span><span class="keyword">val</span> last : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span></span></code></div><div class="spec-doc"><p>Return the last element in the stream, in linear time.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-drain" class="anchored"><a href="#val-drain" class="anchor"></a><code><span><span class="keyword">val</span> drain : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><h2 id="io-streams"><a href="#io-streams" class="anchor"></a>IO Streams</h2><div class="odoc-spec"><div class="spec value" id="val-of_file" class="anchored"><a href="#val-of_file" class="anchor"></a><code><span><span class="keyword">val</span> of_file : <span>string <span class="arrow">&#45;&gt;</span></span> <span>string <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>of_file path</code> is a stream of lines read from the file located at <code>path</code>.</p><p>The file is opened lazily only when the stream is consumed and will be closed even if the stream processing terminates with an exception.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-to_file" class="anchored"><a href="#val-to_file" class="anchor"></a><code><span><span class="keyword">val</span> to_file : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span>string <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>to_file path stream</code> writes lines from <code>stream</code> into the file located at <code>path</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-stdin" class="anchored"><a href="#val-stdin" class="anchor"></a><code><span><span class="keyword">val</span> stdin : <span>string <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>The stream that reads lines from the standard input channel.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-stdout" class="anchored"><a href="#val-stdout" class="anchor"></a><code><span><span class="keyword">val</span> stdout : <span><span>string <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>The stream that writes lines to standard output channel.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-stderr" class="anchored"><a href="#val-stderr" class="anchor"></a><code><span><span class="keyword">val</span> stderr : <span><span>string <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>The stream that writes lines to standard error channel.</p></div></div><h2 id="adaptors"><a href="#adaptors" class="anchor"></a>Adaptors</h2><p>Integration adaptors for <a href="#sources">sources</a>, <a href="#sinks">sinks</a> and <a href="#flows">flows</a>.</p><div class="odoc-spec"><div class="spec value" id="val-from" class="anchored"><a href="#val-from" class="anchor"></a><code><span><span class="keyword">val</span> from : <span><span><span class="type-var">'a</span> <a href="../index.html#type-source">source</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>from source</code> is a stream created from a source.</p><p>Examples</p><pre><code># Stream.len (Stream.from (Source.list [0; 1; 2]))
- : int = 3</code></pre></div></div><div class="odoc-spec"><div class="spec value" id="val-into" class="anchored"><a href="#val-into" class="anchor"></a><code><span><span class="keyword">val</span> into : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="../index.html#type-sink">sink</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span></span></code></div><div class="spec-doc"><p><code>into sink stream</code> is the result value produced by streaming all elements of <code>stream</code> into <code>sink</code>.</p><p>Examples</p><pre><code># Stream.into Sink.sum (Stream.of_list [0; 1; 2])
- : int = 3</code></pre></div></div><p><code>fill sink stream</code> is similar to <code>into</code> but, in addition to the result value produced by <code>sink</code>, will optionally return a leftover stream with elements that were not consumed by <code>sink</code>.</p><div class="odoc-spec"><div class="spec value" id="val-via" class="anchored"><a href="#val-via" class="anchor"></a><code><span><span class="keyword">val</span> via : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="../index.html#type-flow">flow</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="../index.html#type-stream">stream</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="../index.html#type-stream">stream</a></span></span></code></div><div class="spec-doc"><p><code>via flow stream</code> is stream produced by transforming all elements of <code>stream</code> via <code>flow</code>.</p><p>Examples</p><pre><code>Stream.count 100
|&gt; Stream.via (Flow.filter (fun x -&gt; x mod 2 = 0))
|&gt; Stream.via (Flow.take 50)
|&gt; Stream.into Sink.sum</code></pre></div></div><div class="odoc-spec"><div class="spec value" id="val-run" class="anchored"><a href="#val-run" class="anchor"></a><code><span><span class="keyword">val</span> run : <span>from:<span><span class="type-var">'a</span> <a href="../index.html#type-source">source</a></span> <span class="arrow">&#45;&gt;</span></span> <span>via:<span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="../index.html#type-flow">flow</a></span> <span class="arrow">&#45;&gt;</span></span> <span>into:<span><span>(<span class="type-var">'b</span>, <span class="type-var">'r</span>)</span> <a href="../index.html#type-sink">sink</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'r</span> * <span><span><span class="type-var">'a</span> <a href="../index.html#type-source">source</a></span> option</span></span></code></div><div class="spec-doc"><p>Fuses sources, sinks and flows and produces a result and a leftover.</p><pre><code>let (r, leftover) = Stream.run ~from:source via:flow ~into:sink</code></pre><p>Streams elements from <code>source</code> into <code>sink</code> via a stream transformer <code>flow</code>. In addition to the result value <code>r</code> produced by <code>sink</code>, a <code>leftover</code> source is returned, if <code>source</code> was not exhausted.</p><p><b>Warning:</b> If a leftover source is produced, it is required to either consume it or manually <a href="../Source/index.html#val-dispose">dispose</a> its resources. Not doing so might lead to resource leaks.</p><p>Examples</p><pre><code># let (x, leftover) =
    let source = Source.list [&quot;1&quot;; &quot;2&quot;; &quot;3&quot;] in
    let flow = Flow.map int_of_string in
    Stream.run ~from:source ~via:flow ~into:Sink.first
val x : int option = Some 1
val leftover : string source option = Some &lt;abstr&gt;
# match leftover with
  | Some source -&gt; Source.dispose source
  | None -&gt; print_endline &quot;No leftover&quot;
- : unit = ()</code></pre></div></div><h2 id="syntax-defintions"><a href="#syntax-defintions" class="anchor"></a>Syntax defintions</h2><p>Streams can be constructed with the let-binding syntax which is similar to <a href="https://en.wikipedia.org/wiki/List_comprehension">list comprehensions</a>. The following example demonstrates this feature:</p><pre><code>open Stream.Syntax

let items =
  let* n = Stream.range 1 3 in
  let* c = Stream.of_list ['x'; 'y'] in
  yield (n, c) in
assert (Stream.to_list items = [(1, 'x'); (1, 'y'); (2, 'x'); (2, 'y')])</code></pre><div class="odoc-spec"><div class="spec module" id="module-Syntax" class="anchored"><a href="#module-Syntax" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Syntax/index.html">Syntax</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Module with syntax definitions for streams.</p></div></div></div></body></html>