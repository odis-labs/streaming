<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Streaming (streaming.Streaming)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../index.html">streaming</a> &#x00BB; Streaming</nav><header class="odoc-preamble"><h1>Module <code><span>Streaming</span></code></h1><p>Streaming abstractions that combine, transform and reduce large amounts of sequential data efficiently, in constant space and without leaking resources.</p></header><nav class="odoc-toc"><ul><li><a href="#sources">Sources</a></li><li><a href="#sinks">Sinks</a></li><li><a href="#flows">Flows</a></li><li><a href="#streams">Streams</a></li></ul></nav><div class="odoc-content"><h2 id="sources"><a href="#sources" class="anchor"></a>Sources</h2><p>Sources are decoupled producer of values.</p><p>Elements are pulled from a source when needed. A source can have an internal state that will be lazily initialized when (and if) a consumer requests elements. The internal state will be safely disposed when the source runs out of elements, when the consumer terminates, or if an exception is raised at any point in the streaming pipeline.</p><p>Sources are a great way to define decoupled producers that can be consumed with <a href="Stream/index.html#val-from"><code>Stream.from</code></a>. To learn more about how to create sources see <a href="Source/index.html#creating-a-source">&quot;Creating a source&quot;</a>.</p><p>The following example creates a source that counts down to zero:</p><pre><code>let countdown n =
  let init () = n in
  let pull i =
    if i = 0 then None
    else Some (i, i - 1) in
  Source.make ~init ~pull ()</code></pre><p>It can be consumed with:</p><pre><code># Stream.(from (countdown 3) |&gt; into Sink.sum)
- : int = 6</code></pre><div class="odoc-spec"><div class="spec type" id="type-source" class="anchored"><a href="#type-source" class="anchor"></a><code><span><span class="keyword">type</span> <span>+'a source</span></span><span> = </span></code><table><tr id="type-source.Source" class="anchored"><td class="def variant constructor"><a href="#type-source.Source" class="anchor"></a><code><span>| </span><span><span class="constructor">Source</span> : </span><span>{</span></code><table><tr id="type-source.init" class="anchored"><td class="def record field"><a href="#type-source.init" class="anchor"></a><code><span>init : <span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'s</span>;</span></code></td></tr><tr id="type-source.pull" class="anchored"><td class="def record field"><a href="#type-source.pull" class="anchor"></a><code><span>pull : <span><span class="type-var">'s</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'s</span>)</span> option</span>;</span></code></td></tr><tr id="type-source.stop" class="anchored"><td class="def record field"><a href="#type-source.stop" class="anchor"></a><code><span>stop : <span><span class="type-var">'s</span> <span class="arrow">&#45;&gt;</span></span> unit;</span></code></td></tr></table><code><span>}</span><span> <span class="arrow">&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="#type-source">source</a></span></span></code></td></tr></table></div><div class="spec-doc"><p>Type for sources that produce elements of type <code>'a</code>.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Source" class="anchored"><a href="#module-Source" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Source/index.html">Source</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Module with defintions for sources.</p></div></div><h2 id="sinks"><a href="#sinks" class="anchor"></a>Sinks</h2><p>Sinks are decoupled consumer of values.</p><p>Sinks are streaming abstractions that consume values and produce an aggregated value as a result. The result value is extracted from an internal state that is built incrementally. The internal state can acquire resources that are guaranteed to be terminated when the sink is filled.</p><p>Sinks are a great way to define decoupled consumers that can be filled with <a href="Stream/index.html#val-into"><code>Stream.into</code></a>. To learn more about how to create sinks see <a href="Sink/index.html#creating-a-sink">&quot;Creating a sink&quot;</a>.</p><p>The following example demonstrates a sink that consumes all elements into a list:</p><pre><code>let list_sink =
  let init () = [] in
  let push acc x = x :: acc in
  let stop acc = List.rev acc in
  Sink.make ~init ~push ~stop ()</code></pre><p>It can be used with:</p><pre><code># Stream.(iota 5 |&gt; into list_sink)
- : int list = [0; 1; 2; 3; 4]</code></pre><div class="odoc-spec"><div class="spec type" id="type-sink" class="anchored"><a href="#type-sink" class="anchor"></a><code><span><span class="keyword">type</span> <span>('a, 'b) sink</span></span><span> = </span></code><table><tr id="type-sink.Sink" class="anchored"><td class="def variant constructor"><a href="#type-sink.Sink" class="anchor"></a><code><span>| </span><span><span class="constructor">Sink</span> : </span><span>{</span></code><table><tr id="type-sink.init" class="anchored"><td class="def record field"><a href="#type-sink.init" class="anchor"></a><code><span>init : <span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'s</span>;</span></code></td></tr><tr id="type-sink.push" class="anchored"><td class="def record field"><a href="#type-sink.push" class="anchor"></a><code><span>push : <span><span class="type-var">'s</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'s</span>;</span></code></td></tr><tr id="type-sink.full" class="anchored"><td class="def record field"><a href="#type-sink.full" class="anchor"></a><code><span>full : <span><span class="type-var">'s</span> <span class="arrow">&#45;&gt;</span></span> bool;</span></code></td></tr><tr id="type-sink.stop" class="anchored"><td class="def record field"><a href="#type-sink.stop" class="anchor"></a><code><span>stop : <span><span class="type-var">'s</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'r</span>;</span></code></td></tr></table><code><span>}</span><span> <span class="arrow">&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r</span>)</span> <a href="#type-sink">sink</a></span></span></code></td></tr></table></div><div class="spec-doc"><p>Type for sinks that consume elements of type <code>'a</code> and, once done, produce a value of type <code>'b</code>.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Sink" class="anchored"><a href="#module-Sink" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Sink/index.html">Sink</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Module with defintions for sinks.</p></div></div><h2 id="flows"><a href="#flows" class="anchor"></a>Flows</h2><p>Flows are decoupled transformers of values.</p><p>Flows define streaming transformation, filtering or groupping operations that are fully disconnected from input and output. Their implementation intercepts an internal folding function and modifies the input one value at a time.</p><p>Flows are a great way to define decoupled transformations that can be used with <a href="Stream/index.html#val-via"><code>Stream.via</code></a>.</p><p>A flow can be applied to a stream with <a href="Stream/index.html#val-via"><code>Stream.via</code></a>:</p><pre><code># Stream.range 10 100
  |&gt; Stream.via (Flow.map (fun x -&gt; x + 1))
  |&gt; Stream.into Sink.sum
- : int = 4995</code></pre><p>Flows can also be composed to form a pipeline:</p><pre><code># let flow = Flow.(map (fun x -&gt; x + 1) &gt;&gt; filter (fun x -&gt; x mod 2 = 0)) in
  Stream.range 10 100
  |&gt; Stream.via flow
  |&gt; Stream.into Sink.sum
- : int = 2475</code></pre><div class="odoc-spec"><div class="spec type" id="type-flow" class="anchored"><a href="#type-flow" class="anchor"></a><code><span><span class="keyword">type</span> <span>('a, 'b) flow</span></span><span> = </span><span>{</span></code><table><tr id="type-flow.flow" class="anchored"><td class="def record field"><a href="#type-flow.flow" class="anchor"></a><code><span>flow : r. <span><span><span>(<span class="type-var">'b</span>, <span class="type-var">'r</span>)</span> <a href="#type-sink">sink</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'r</span>)</span> <a href="#type-sink">sink</a></span>;</span></code></td></tr></table><code><span>}</span></code></div><div class="spec-doc"><p>Stream transformers that consume values of type <code>'a</code> and produce values of type <code>'b</code>.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Flow" class="anchored"><a href="#module-Flow" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Flow/index.html">Flow</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Module with definitions for flows.</p></div></div><h2 id="streams"><a href="#streams" class="anchor"></a>Streams</h2><p>Streams combine sources, sinks and flows into a flexible streaming toolkit.</p><p>Stream is a purely functional abstraction for incremental, push-based, sequential processing of elements. Streams can be easily and efficiently transformed and concatenated.</p><p>Stream operations do not leak resources. This is guaranteed in the presence of early termination (when not all stream elements are consumed) or in case of exceptions in the streaming pipeline.</p><p>Streams are built to be compatible with <a href="#sources">sources</a>, <a href="#sinks">sinks</a> and <a href="#flows">flows</a>. To create a stream that produces all elements from a source use <a href="Stream/index.html#val-from"><code>Stream.from</code></a>, to consume a stream with a sink use <a href="Stream/index.html#val-into"><code>Stream.into</code></a> and to transform stream elements with a flow use <a href="Stream/index.html#val-via"><code>Stream.via</code></a>. For more sophisticated pipelines that might have source leftovers, <a href="Stream/index.html#val-run"><code>Stream.run</code></a> can be used.</p><p>A simple echo program that loops over standard input and prints every line to standard output until Ctrl-D is hit:</p><pre><code># Stream.stdin |&gt; Stream.stdout;;
hello&lt;Enter&gt;
hello
world&lt;Enter&gt;
world
&lt;Ctrl+d&gt;
- : unit = ()</code></pre><div class="odoc-spec"><div class="spec type" id="type-stream" class="anchored"><a href="#type-stream" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a stream</span></span><span> = </span><span>{</span></code><table><tr id="type-stream.stream" class="anchored"><td class="def record field"><a href="#type-stream.stream" class="anchor"></a><code><span>stream : r. <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'r</span>)</span> <a href="#type-sink">sink</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'r</span>;</span></code></td></tr></table><code><span>}</span></code></div><div class="spec-doc"><p>Type for streams with elements of type <code>'a</code>.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Stream" class="anchored"><a href="#module-Stream" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Stream/index.html">Stream</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Module with defintions for streams.</p></div></div></div></body></html>