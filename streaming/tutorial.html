<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>tutorial (streaming.tutorial)</title><link rel="stylesheet" href="../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="index.html">Up</a> â€“ <a href="index.html">streaming</a> &#x00BB; tutorial</nav><header class="odoc-preamble"><h1 id="streaming---tutorial"><a href="#streaming---tutorial" class="anchor"></a>Streaming - Tutorial</h1></header><nav class="odoc-toc"><ul><li><a href="#creating-a-sink">Creating a sink</a><ul><li><a href="#state-management-in-sinks">State management in sinks</a><ul><li><a href="#lazy-state-initialization">Lazy state initialization</a></li></ul></li></ul></li></ul></nav><div class="odoc-content"><h2 id="creating-a-sink"><a href="#creating-a-sink" class="anchor"></a>Creating a sink</h2><p>Implementing custom sinks is useful to create a collection of reusable streaming consumers for your application.</p><p>The following example demonstrates a sink that consumes all elements into a list:</p><pre><code>let list_sink =
  let init () = [] in
  let push acc x = x :: acc in
  let stop acc = List.rev acc in
  Sink.make ~init ~push ~stop ()</code></pre><p>Alternatively, use of the provided sinks in <a href="Streaming/Sink/index.html"><code>Streaming.Sink</code></a>.</p><h3 id="state-management-in-sinks"><a href="#state-management-in-sinks" class="anchor"></a>State management in sinks</h3><p>The internal state in sinks can hold an accumulator value or a resource used to consume input. For simple sinks such as <code>list_sink</code> above, the initial state is a plain list value, updated with <code>push</code> and reversed on <code>stop</code>. For more complex sinks that have to manage effectful resources such as files, database handlers, or mutable accumulators it is important to follow some safety rules and recommendations.</p><h4 id="lazy-state-initialization"><a href="#lazy-state-initialization" class="anchor"></a>Lazy state initialization</h4><p>Computations in streaming are always lazy and delay resource initialization until data needs to be pulled from sources or pushed into sinks. This is a useful property to have to avoid excessive or unnecessary resource utilization and leaks.</p><p>To achieve this, state needs to be lazy, both when initialized and when terminated. Let's define a sink that writes lines to an output channel as an example:</p><pre><code>(* Trace calls to open/close to see if they're being used. *)
#trace open_out
#trace close_out

let write_lines file =
  let init () = lazy (open_out file) in
  let stop lazy_chan =
    if Lazy.is_val lazy_chan then
      close_out (Lazy.force lazy_chan) in
  let push lazy_chan x =
    output_string (Lazy.force lazy_chan) (x ^ &quot;\n&quot;);
    lazy_chan in
  Sink.make () ~init ~stop ~push</code></pre><p>Let look at how state is managed in this sink:</p><ul><li><code>init</code> is lazy, delaying the channel creation until it's needed in <code>push</code>;</li><li><code>stop</code> does not force the lazy state if it has not be forced by <code>push</code>;</li><li><code>push</code> forces the lazy state, actually opening the output channel this way.</li></ul><p>Concretely, this means that the following code will not open any files at all:</p><pre><code>Stream.(of_list [&quot;a&quot;; &quot;b&quot;; &quot;c&quot;] |&gt; take 0 |&gt; into (write_lines &quot;/tmp/data.txt&quot;))</code></pre><p>Similar considerations should be taken care when defining <code>fill</code> in <a href="Streaming/Sink/index.html#val-make"><code>Streaming.Sink.make</code></a>. When possible, checking if a sink's state is full should be a lazy and cheap operation.</p></div></body></html>