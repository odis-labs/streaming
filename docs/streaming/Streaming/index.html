<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Streaming (streaming.Streaming)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">streaming</a> &#x00BB; Streaming</nav><h1>Module <code>Streaming</code></h1><p>Streaming abstractions that combine, transform and reduce large amounts of sequential data efficiently, in constant space and without leaking resources.</p><nav class="toc"><ul><li><a href="#sources">Sources</a></li><li><a href="#sinks">Sinks</a></li><li><a href="#flows">Flows</a></li><li><a href="#streams">Streams</a></li></ul></nav></header><section><header><h2 id="sources"><a href="#sources" class="anchor"></a>Sources</h2><p>Sources are decoupled producer of values.</p><p>Elements are pulled from a source when needed. A source can have an internal state that will be lazily initialized when (and if) a consumer requests elements. The internal state will be safely disposed when the source runs out of elements, when the consumer terminates, or if an exception is raised at any point in the streaming pipeline.</p><p>Sources are a great way to define decoupled producers that can be consumed with <a href="Stream/index.html#val-from"><code>Stream.from</code></a>. To learn more about how to create sources see <a href="Source/index.html#creating-a-source">&quot;Creating a source&quot;</a>.</p><p>The following example creates a source that counts down to zero:</p><pre><code class="ml">let countdown n =
  let init () = n in
  let pull i =
    if i = 0 then None
    else Some (i, i - 1) in
  Source.make ~init ~pull ()</code></pre><p>It can be consumed with:</p><pre><code class="ml"># Stream.(from (countdown 3) |&gt; into Sink.sum)
- : int = 6</code></pre></header><dl><dt class="spec type" id="type-source"><a href="#type-source" class="anchor"></a><code><span class="keyword">type</span> <span>'a source</span></code></dt><dd><p>Type for sources that produce elements of type <code>'a</code>.</p></dd></dl><dl><dt class="spec module" id="module-Source"><a href="#module-Source" class="anchor"></a><code><span class="keyword">module</span> <a href="Source/index.html">Source</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Module with defintions for sources.</p></dd></dl></section><section><header><h2 id="sinks"><a href="#sinks" class="anchor"></a>Sinks</h2><p>Sinks are decoupled consumer of values.</p><p>Sinks are streaming abstractions that consume values and produce an aggregated value as a result. The result value is extracted from an internal state that is built incrementally. The internal state can aquire resources that are guaranteed to be terminated when the sink is filled.</p><p>Sinks are a great way to define decoupled consumers that can be filled with <a href="Stream/index.html#val-into"><code>Stream.into</code></a>. To learn more about how to create sinks see <a href="Sink/index.html#creating-a-sink">&quot;Creating a sink&quot;</a>.</p><p>The following example demonstrates a sink that consumes all elements into a list:</p><pre><code class="ml">let list_sink =
  let init () = [] in
  let push acc x = x :: acc in
  let stop acc = List.rev acc in
  Sink.make ~init ~push ~stop ()</code></pre><p>It can be used with:</p><pre><code class="ml"># Stream.(iota 5 |&gt; into list_sink)
- : int list = [0; 1; 2; 3; 4]</code></pre></header><dl><dt class="spec type" id="type-sink"><a href="#type-sink" class="anchor"></a><code><span class="keyword">type</span> <span>('a, 'b) sink</span></code></dt><dd><p>Type for sinks that consume elements of type <code>'a</code> and, once done, produce a value of type <code>'b</code>.</p></dd></dl><dl><dt class="spec module" id="module-Sink"><a href="#module-Sink" class="anchor"></a><code><span class="keyword">module</span> <a href="Sink/index.html">Sink</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Module with defintions for sinks.</p></dd></dl></section><section><header><h2 id="flows"><a href="#flows" class="anchor"></a>Flows</h2><p>Flows are decoupled transformers of values.</p><p>Flows define streaming transformation, filtering or groupping operations that are fully disconnected from input and output. Their implementation intercepts an internal folding function and modifies the input one value at a time.</p><p>Flows are a great way to define decoupled transformations that can be used with <a href="Stream/index.html#val-via"><code>Stream.via</code></a>.</p><p>A flow can be applied to a stream with <a href="Stream/index.html#val-via"><code>Stream.via</code></a>:</p><pre><code class="ml"># Stream.range 10 100
  |&gt; Stream.via (Flow.map (fun x -&gt; x + 1))
  |&gt; Stream.into Sink.sum
- : int = 4995</code></pre><p>Flows can also be composed to form a pipeline:</p><pre><code class="ml"># let flow = Flow.(map (fun x -&gt; x + 1) &gt;&gt; filter (fun x -&gt; x mod 2 = 0)) in
  Stream.range 10 100
  |&gt; Stream.via flow
  |&gt; Stream.into Sink.sum
- : int = 2475</code></pre></header><dl><dt class="spec type" id="type-flow"><a href="#type-flow" class="anchor"></a><code><span class="keyword">type</span> <span>('a, 'b) flow</span></code></dt><dd><p>Stream transformers that consume values of type <code>'a</code> and produce values of type <code>'b</code>.</p></dd></dl><dl><dt class="spec module" id="module-Flow"><a href="#module-Flow" class="anchor"></a><code><span class="keyword">module</span> <a href="Flow/index.html">Flow</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Module with definitions for flows.</p></dd></dl></section><section><header><h2 id="streams"><a href="#streams" class="anchor"></a>Streams</h2><p>Streams combine sources, sinks and flows into a flexible streaming toolkit.</p><p>Stream is a purely functional abstraction for incremental, push-based, sequential processing of elements. Streams can be easily and efficiently transformed and concatenated.</p><p>Stream operations do not leak resources. This is guaranteed in the presence of early termination (when not all stream elements are consumed) or in case of exceptions in the streaming pipeline.</p><p>Streams are built to be compatible with <a href="#sources">sources</a>, <a href="#sinks">sinks</a> and <a href="#flows">flows</a>. To create a stream that produces all elements from a source use <a href="Stream/index.html#val-from"><code>Stream.from</code></a>, to consume a stream with a sink use <a href="Stream/index.html#val-into"><code>Stream.into</code></a> and to transform stream elements with a flow use <a href="Stream/index.html#val-via"><code>Stream.via</code></a>. For more sophisticated pipelines that might have source leftovers, <a href="Stream/index.html#val-run"><code>Stream.run</code></a> can be used.</p><p>A simple echo program that loops over standard input and prints every line to standard output until Ctrl-D is hit:</p><pre><code class="ml"># Stream.stdin |&gt; Stream.stdout;;
hello&lt;Enter&gt;
hello
world&lt;Enter&gt;
world
&lt;Ctrl+d&gt;
- : unit = ()</code></pre></header><dl><dt class="spec type" id="type-stream"><a href="#type-stream" class="anchor"></a><code><span class="keyword">type</span> <span>'a stream</span></code></dt><dd><p>Type for streams with elements of type <code>'a</code>.</p></dd></dl><dl><dt class="spec module" id="module-Stream"><a href="#module-Stream" class="anchor"></a><code><span class="keyword">module</span> <a href="Stream/index.html">Stream</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Module with defintions for streams.</p></dd></dl></section></div></body></html>